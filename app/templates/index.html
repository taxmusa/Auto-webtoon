<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ title }}</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><text y='28' font-size='28'>🎨</text></svg>" type="image/svg+xml">
    <link href="https://fonts.googleapis.com/css2?family=Pretendard:wght@400;500;600;700;800&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --primary: #6366f1;
            --primary-hover: #4f46e5;
            --primary-light: #e0e7ff;
            --bg: #0f172a;
            --bg-card: #1e293b;
            --bg-input: #334155;
            --text: #f1f5f9;
            --text-muted: #94a3b8;
            --border: #475569;
            --success: #22c55e;
            --warning: #f59e0b;
            --danger: #ef4444;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Pretendard', -apple-system, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
        }

        /* Header */
        header {
            background: var(--bg-card);
            border-bottom: 1px solid var(--border);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 1.25rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary), #a855f7);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .api-badge {
            padding: 2px 8px;
            border-radius: 4px;
            background: rgba(148,163,184,0.1);
            color: var(--text-muted);
            font-weight: 500;
            transition: all 0.2s;
        }
        .api-badge:hover { background: rgba(148,163,184,0.2); }
        @keyframes slideIn { from { transform: translateY(-10px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

        /* Progress Steps */
        .progress-bar {
            background: var(--bg-card);
            padding: 1.5rem 2rem;
            border-bottom: 1px solid var(--border);
        }

        .steps {
            display: flex;
            justify-content: center;
            gap: 0;
            max-width: 1100px;
            margin: 0 auto;
        }

        .step {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--text-muted);
            font-size: 0.875rem;
            position: relative;
            cursor: pointer;
            transition: all 0.2s;
        }

        .step:hover {
            color: var(--primary);
        }

        .step.active {
            color: var(--primary);
            font-weight: 600;
        }

        .step.done {
            color: var(--success);
        }

        .step.done:hover {
            color: var(--primary);
        }

        .step-num {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: var(--bg-input);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .step.active .step-num {
            background: var(--primary);
            color: white;
        }

        .step.done .step-num {
            background: var(--success);
            color: white;
        }

        .step-line {
            width: 60px;
            height: 2px;
            background: var(--border);
            margin: 0 0.5rem;
        }

        .step.done+.step-line {
            background: var(--success);
        }

        /* Main Content */
        main {
            max-width: 1100px;
            margin: 2rem auto;
            padding: 0 1rem;
        }

        /* Step Content - Page View Behavior */
        .step-content {
            display: none;
            animation: fadeIn 0.3s ease-in-out;
        }

        .step-content.active {
            display: block;
        }

        .spinner {
            width: 32px;
            height: 32px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* ── 씬 카드 2단 레이아웃 ── */
        .scene-card {
            display: flex;
            border: 1px solid var(--border);
            border-radius: 10px;
            margin-bottom: 0.6rem;
            background: var(--bg-card);
            overflow: hidden;
            min-height: 120px;
        }
        .scene-card.cover-scene {
            border: 2px solid var(--primary);
            background: linear-gradient(135deg, rgba(99,102,241,0.05), rgba(139,92,246,0.05));
        }
        .scene-card.warn-scene {
            border-color: var(--warning);
        }
        .scene-card-left {
            flex: 7;
            padding: 0.6rem 0.7rem;
            min-width: 0;
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
        }
        .scene-card-right {
            flex: 3;
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 0.5rem;
            min-width: 140px;
            max-width: 250px;
            background: rgba(0,0,0,0.01);
        }
        .scene-img-area {
            width: 100%;
            aspect-ratio: 4 / 5;
            max-height: 280px;
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-input);
            border: 1px dashed var(--border);
            position: relative;
        }
        .scene-img-area img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 7px;
        }
        .scene-img-actions {
            display: flex;
            gap: 4px;
            margin-top: 6px;
            width: 100%;
            justify-content: center;
        }
        .scene-img-actions button {
            background: none;
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            padding: 2px 6px;
            font-size: 0.72rem;
            color: var(--text-muted);
            transition: all 0.15s;
        }
        .scene-img-actions button:hover {
            border-color: var(--primary);
            color: var(--primary);
            background: rgba(99,102,241,0.06);
        }
        .scene-img-status {
            font-size: 0.65rem;
            color: var(--text-muted);
            margin-top: 4px;
            text-align: center;
        }
        .char-counter {
            font-size: 0.6rem;
            color: var(--text-muted);
            text-align: right;
            margin-top: 1px;
        }
        .char-counter.over {
            color: var(--danger);
            font-weight: 600;
        }

        /* 이미지 생성 컨트롤 바 */
        .gen-control-bar {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 0.8rem 1rem;
            margin-top: 1rem;
        }
        .gen-control-bar .gen-bar-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-bottom: 0.5rem;
        }
        .gen-control-bar .gen-bar-progress {
            height: 6px;
            background: var(--bg-input);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 0.4rem;
        }
        .gen-control-bar .gen-bar-fill {
            height: 100%;
            background: var(--primary);
            border-radius: 3px;
            transition: width 0.3s;
        }

        @media (max-width: 640px) {
            .scene-card {
                flex-direction: column;
            }
            .scene-card-right {
                max-width: 100%;
                border-left: none;
                border-top: 1px solid var(--border);
                flex-direction: row;
                gap: 0.5rem;
                padding: 0.5rem;
            }
            .scene-img-area {
                width: 80px;
                height: 80px;
                aspect-ratio: unset;
            }
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Cards */
        .card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 1.5rem;
        }

        .card-title {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
        }

        .card-desc {
            color: var(--text-muted);
            margin-bottom: 1.5rem;
        }

        /* Form Elements */
        .form-group {
            margin-bottom: 1.5rem;
        }

        label {
            display: block;
            font-weight: 500;
            margin-bottom: 0.5rem;
        }

        input,
        textarea,
        select {
            width: 100%;
            padding: 0.75rem 1rem;
            background: var(--bg-input);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            font-size: 1rem;
        }

        input:focus,
        textarea:focus,
        select:focus {
            outline: none;
            border-color: var(--primary);
        }

        /* Buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-weight: 600;
            font-size: 1rem;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-hover);
        }

        .btn-secondary {
            background: var(--bg-input);
            color: var(--text);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--border);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Outline Button (다크 테마 통일) */
        .btn-outline {
            background: transparent;
            color: var(--text);
            border: 1px solid var(--border);
        }

        .btn-outline:hover {
            background: var(--bg-input);
            border-color: var(--primary);
            color: var(--primary);
        }

        /* Small Button */
        .btn-sm {
            padding: 0.4rem 0.85rem;
            font-size: 0.85rem;
            border-radius: 6px;
        }

        /* File Input 다크 테마 */
        input[type="file"] {
            background: var(--bg-input);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            padding: 0.5rem;
            cursor: pointer;
        }

        input[type="file"]::file-selector-button {
            background: var(--bg-card);
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 0.4rem 0.85rem;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            margin-right: 0.75rem;
            transition: all 0.2s;
        }

        input[type="file"]::file-selector-button:hover {
            background: var(--bg-input);
            border-color: var(--primary);
            color: var(--primary);
        }

        /* 모달 내부 다크 텍스트 통일 */
        .modal-content-dark h3,
        .modal-content-dark h4,
        .modal-content-dark h5,
        .modal-content-dark label,
        .modal-content-dark p {
            color: var(--text);
        }


        /* Mode Selection */
        .mode-cards {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        .mode-card {
            background: var(--bg-input);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 1.5rem;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .mode-card:hover {
            border-color: var(--primary);
        }

        .mode-card.selected {
            border-color: var(--primary);
            background: var(--primary-light);
        }

        .mode-card.selected {
            background: rgba(99, 102, 241, 0.1);
        }

        .mode-icon {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }

        .mode-title {
            font-weight: 700;
            font-size: 1.125rem;
            margin-bottom: 0.25rem;
        }

        .mode-desc {
            color: var(--text-muted);
            font-size: 0.875rem;
        }

        /* Scene Cards */
        .scene-card {
            background: var(--bg-input);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .scene-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .scene-num {
            font-weight: 700;
            color: var(--primary);
        }

        .scene-status {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            background: var(--warning);
            color: black;
        }

        /* Character Card */
        .char-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1rem;
            display: flex;
            gap: 1rem;
            align-items: center;
            margin-bottom: 1rem;
            transition: all 0.2s;
        }

        .char-card:hover {
            border-color: var(--primary);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .char-avatar {
            width: 60px;
            height: 60px;
            background: var(--bg-input);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }

        .char-info {
            flex: 1;
        }

        .char-name {
            font-weight: 600;
            font-size: 1rem;
            margin-bottom: 0.25rem;
        }

        .char-role {
            font-size: 0.75rem;
            color: var(--text-muted);
            background: var(--bg-input);
            padding: 2px 8px;
            border-radius: 10px;
        }

        /* Rule Warning */
        .rule-warning {
            background: rgba(255, 152, 0, 0.1);
            border-left: 3px solid var(--warning);
            padding: 0.5rem 0.75rem;
            border-radius: 4px;
            margin-top: 0.5rem;
            font-size: 0.75rem;
            color: #ff9800;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .tab-container {
            display: flex;
            gap: 1rem;
            border-bottom: 1px solid var(--border);
            margin-bottom: 1.5rem;
        }

        .tab {
            padding: 0.5rem 1rem;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            color: var(--text-muted);
            transition: all 0.2s;
        }

        .tab:hover {
            color: var(--text);
        }

        .tab.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
            font-weight: 600;
        }

        /* --- Style System 2.0 UI Improvements --- */
        .style-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .style-select-card {
            background: var(--bg-card);
            /* Keep card bg */
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1.25rem;
            transition: all 0.2s;
        }

        .style-select-card:hover {
            border-color: var(--primary);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .style-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .style-title {
            font-size: 1.1rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--text);
        }

        .selected-style-display {
            background: var(--bg-input);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 80px;
            font-weight: 600;
            color: var(--primary);
            /* Highlight color */
            text-align: center;
            transition: all 0.2s;
        }

        .selected-style-display:hover {
            background: var(--bg);
        }

        /* Modal Dark Theme */
        .modal-content-dark {
            background: var(--bg-card) !important;
            color: var(--text) !important;
            border: 1px solid var(--border) !important;
        }

        .modal-header-dark {
            border-bottom: 1px solid var(--border) !important;
        }

        .style-list-dark {
            border-right: 1px solid var(--border) !important;
        }

        .style-item-dark {
            border-bottom: 1px solid var(--border) !important;
            color: var(--text) !important;
            transition: background 0.1s;
        }

        .style-item-dark:hover {
            background: var(--bg-input) !important;
        }

        .preview-box {
            background: var(--bg);
            border: 2px dashed var(--border);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            transition: all 0.2s;
        }

        .preview-box:hover {
            border-color: var(--text-muted);
        }

        .tab.active {
            color: var(--primary);
            border-color: var(--primary);
            font-weight: 600;
        }

        /* Settings Grid */
        .settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        /* 말풍선 편집기 반응형 */
        @media (max-width: 800px) {
            #bubble-edit-main {
                grid-template-columns: 1fr !important;
            }
            #bubble-edit-main > div:last-child {
                max-height: 400px !important;
            }
        }
    </style>
</head>

<body>
    <header>
        <a href="/" class="logo" style="text-decoration: none;">🎨 Webtoon Auto-Generator Pro</a>
        <div style="display: flex; gap: 0.75rem; align-items: center;">
            <button class="btn btn-secondary" onclick="toggleProjectPanel()" id="btn-project-manager"
                style="font-size:0.78rem; padding:5px 14px; border-radius:8px; display:inline-flex; align-items:center; gap:4px; background:rgba(99,102,241,0.12); border:1px solid rgba(99,102,241,0.25); color:var(--primary);">
                📂 저장 및 불러오기
            </button>
            <span id="login-status" style="font-size: 0.875rem; color: var(--text-muted);">Guest User</span>
            <a href="/settings" class="btn btn-secondary"
                style="font-size:0.78rem; padding:5px 14px; border-radius:8px; display:inline-flex; align-items:center; gap:4px; text-decoration:none; color:var(--text);">
                ⚙️ 설정
            </a>
        </div>
    </header>

    <!-- API 상태 바 -->
    <div id="api-status-bar" style="max-width:1200px; margin:0 auto; padding:4px 2rem; display:flex; gap:8px; align-items:center; font-size:0.72rem; flex-wrap:wrap;">
        <span style="color:var(--text-muted); font-weight:600;">API:</span>
        <span class="api-badge" id="api-st-gemini" title="Gemini" style="cursor:pointer;" onclick="location.href='/settings'">⚪ Gemini</span>
        <span class="api-badge" id="api-st-instagram" title="Instagram" style="cursor:pointer;" onclick="location.href='/settings'">⚪ Instagram</span>
        <span class="api-badge" id="api-st-cloudinary" title="Cloudinary" style="cursor:pointer;" onclick="location.href='/settings'">⚪ Cloudinary</span>
    </div>

    <div id="project-list-panel" style="display:none; max-width:1200px; margin:0 auto 0.5rem; padding:0 2rem;">
        <div style="background:var(--bg-card); border:1px solid var(--border); border-radius:10px; padding:1rem; box-shadow:0 4px 12px rgba(0,0,0,0.15);">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.75rem;">
                <h3 style="margin:0; font-size:0.95rem;">📂 프로젝트 관리</h3>
                <button onclick="document.getElementById('project-list-panel').style.display='none'" style="background:none; border:none; cursor:pointer; font-size:1.2rem; color:var(--text-muted);">×</button>
            </div>
            <!-- 저장 버튼 영역 -->
            <div style="display:flex; gap:0.5rem; margin-bottom:0.75rem; padding-bottom:0.75rem; border-bottom:1px solid var(--border);">
                <button class="btn btn-primary" onclick="saveCurrentProject()" style="font-size:0.82rem; padding:6px 16px;">💾 현재 프로젝트 저장</button>
                <span id="project-save-hint" style="font-size:0.75rem; color:var(--text-muted); align-self:center;">세션이 시작되면 저장할 수 있습니다</span>
            </div>
            <!-- 프로젝트 목록 -->
            <div style="font-size:0.82rem; font-weight:600; margin-bottom:0.5rem; color:var(--text-muted);">저장된 프로젝트</div>
            <div id="project-list-content" style="max-height:300px; overflow-y:auto;">로딩 중...</div>
        </div>
    </div>

    <div class="progress-bar">
        <div class="steps">
            <!-- 프리셋관리 탭: 워크플로우 바깥, 별도 색상 -->
            <div class="step" data-step="preset" onclick="navigateToStep('preset')" style="background:linear-gradient(135deg,#7c3aed,#6d28d9);color:#fff;border-radius:8px;padding:6px 14px;font-weight:700;cursor:pointer;">🎨 프리셋</div>
            <div class="step-line" style="opacity:0.3;"></div>
            <!-- 워크플로우 탭 1~6 -->
            <div class="step active" data-step="1" onclick="navigateToStep(1)"><span class="step-num">1</span> 시작</div>
            <div class="step-line"></div>
            <div class="step" data-step="2" onclick="navigateToStep(2)"><span class="step-num">2</span> 자료수집</div>
            <div class="step-line"></div>
            <div class="step" data-step="3" onclick="navigateToStep(3)"><span class="step-num">3</span> 스토리+이미지</div>
            <div class="step-line"></div>
            <div class="step" data-step="4" onclick="navigateToStep(4)"><span class="step-num">4</span> 편집</div>
            <div class="step-line"></div>
            <div class="step" data-step="5" onclick="navigateToStep(5)"><span class="step-num">5</span> 발행</div>
        </div>
    </div>

    <main>
        <div class="step-content active" id="step-1">
            <div class="card">
                <h2 class="card-title">🚀 워크플로우 시작</h2>
                <!-- Mode Cards Hidden (Optional: Can keep them if needed, but user didn't ask to remove) -->
                <div class="mode-cards" style="margin-bottom: 2rem;">
                    <div class="mode-card selected" data-mode="auto" onclick="selectMode('auto')">
                        <div class="mode-icon">🤖</div>
                        <div class="mode-title">자동 모드</div>
                        <div class="mode-desc">키워드만 입력하면 AI가 자료 수집부터스토리까지 모두 처리합니다.</div>
                    </div>
                    <div class="mode-card" data-mode="manual" onclick="selectMode('manual')">
                        <div class="mode-icon">✍️</div>
                        <div class="mode-title">수동 모드</div>
                        <div class="mode-desc">직접 작성한 시나리오나 텍스트를 바탕으로 이미지를 생성합니다.</div>
                    </div>
                </div>

                <div id="keyword-input-area">
                    <div class="form-group">
                        <label for="keyword">무엇에 대해 설명하는 웹툰을 만들까요?</label>
                        <div style="margin-bottom: 0.5rem;">
                            <textarea id="keyword" rows="3" placeholder="예: 재테크 기초 알려주기, 건강한 식습관, 직장인 꿀팁"
                                style="width:100%; resize:vertical; min-height:60px;"
                                onkeydown="if(event.key==='Enter' && !event.shiftKey){event.preventDefault(); startWorkflow();}"></textarea>
                        </div>

                        <!-- AI Model Selection -->
                        <div
                            style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; color: var(--text-muted); flex-wrap: wrap;">
                            <span>자료수집/글 AI 모델:</span>
                            <select id="ai-model-select"
                                style="padding: 2px 8px; border-radius: 4px; border: 1px solid var(--border); background: var(--bg-card); color: var(--text);">
                                <option value="gemini-3-flash-preview" selected>Gemini 3.0 Flash (빠름)</option>
                                <option value="gemini-3-pro-preview">Gemini 3.0 Pro (고성능)</option>
                            </select>
                        </div>
                        <div style="display: flex; align-items: center; gap: 0.4rem; font-size: 0.78rem; color: var(--text-muted); margin-top: 4px; padding: 4px 8px; background: rgba(99,102,241,0.06); border-radius: 6px; border: 1px solid rgba(99,102,241,0.15);">
                            <span style="font-weight: 600; color: var(--primary);">이미지 생성 AI:</span>
                            <span>Gemini 3.0 Pro Image (고정) — 최고 품질의 이미지를 위해 항상 Pro 모델을 사용합니다.</span>
                        </div>
                    </div>
                </div>

                <div id="manual-input-area" style="display : none;">
                    <div class="form-group">
                        <label for="manual-script">시나리오 또는 텍스트 입력</label>
                        <textarea id="manual-script" rows="5" placeholder="직접 작성한 시나리오나 텍스트 내용을 입력해주세요."></textarea>
                    </div>
                </div>

                <!-- 스마트 분석 결과 (AI가 분야 감지 후 표시) -->
                <div id="smart-analysis-result" style="display:none; margin-top:1rem; padding:1rem; background:var(--bg-input); border-radius:8px; border:1px solid var(--border);">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.75rem;">
                        <span style="font-weight:700;">AI 분석 결과</span>
                        <span id="verification-needed-badge" style="display:none; font-size:0.75rem; padding:2px 8px; border-radius:4px; background:rgba(239,68,68,0.15); color:#ef4444; align-items:center; gap:4px;">⚠️ 법적 검증 권장</span>
                    </div>
                    <div style="display:flex; gap:1rem; align-items:center; flex-wrap:wrap;">
                        <div class="form-group" style="margin-bottom:0; flex:1; min-width:150px;">
                            <label style="font-size:0.8rem; margin-bottom:0.25rem;">감지된 분야</label>
                            <select id="confirmed-field" style="padding:0.5rem; font-size:0.85rem;">
                                <option value="GENERAL">일반</option>
                                <option value="TAX">세금/세무</option>
                                <option value="LAW">법률</option>
                                <option value="MEDICAL">의학/건강</option>
                                <option value="FINANCE">금융/투자</option>
                                <option value="EDUCATION">교육</option>
                                <option value="TECH">기술/IT</option>
                            </select>
                        </div>
                        <div style="text-align:center;">
                            <label style="font-size:0.8rem; color:var(--text-muted);">기준 연도</label>
                            <div id="confirmed-year" style="font-size:1.1rem; font-weight:700;">2026</div>
                            <input type="hidden" id="hidden-target-year" value="2026">
                        </div>
                        <button class="btn btn-primary" onclick="confirmAndStart()" style="padding:0.6rem 1.5rem;">확인 후 자료 수집 시작 →</button>
                    </div>
                </div>
            </div>

            <div class="actions">
                <div></div>
                <!-- Initial Start Button Hidden when Analysis Shown -->
                <button class="btn btn-primary" id="btn-start-next" onclick="startWorkflow()"
                    style="display: block; width: 100%;">
                    웹툰 제작 시작하기 🚀
                </button>
            </div>
        </div>

        <!-- Step 2: 자료 수집 및 추천 -->
        <div class="step-content" id="step-2">
            <div class="loading" id="loading-data">
                <div class="spinner"></div>
                <div>AI가 관련 법령과 상세 정보를 수집하고 있습니다...</div>
            </div>

            <div id="data-review-area" style="display: none;">
                <div class="card">
                    <h2 class="card-title">📚 수집된 상세 정보</h2>
                    <p class="card-desc">AI가 키워드에 맞춰 수집한 내용입니다. 필요 시 본문을 수정하거나 항목을 추가하세요.</p>
                    <div id="data-container"></div>
                    <button class="btn btn-secondary" style="margin-top: 1rem; width: 100%;"
                        onclick="openAddDataModal()">+ 정보 항목 추가</button>
                </div>

                <!-- AI 분할 추천 -->
                <div class="card"
                    style="background: linear-gradient(135deg, rgba(74, 144, 226, 0.05), rgba(74, 144, 226, 0.15)); border: 1px solid var(--primary);">
                    <h3 style="margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.5rem;">🪄 AI 시퀀스 추천
                    </h3>
                    <p style="font-size: 0.875rem; color: var(--text-muted); margin-bottom: 1rem;">수집된 정보의 양을 분석했을 때,
                        다음과 같은 구성을 추천합니다.</p>

                    <div>
                        <label style="font-weight: 600;">총 제작 씬(Scene) 개수 <span style="font-size:0.75rem; color:var(--primary); font-weight:700; background:rgba(99,102,241,0.1); padding:2px 6px; border-radius:4px; margin-left:4px;">표지 포함</span></label>
                        <div style="display: flex; align-items: center; gap: 1rem; margin-top: 0.5rem;">
                            <input type="number" id="total-scene-count" value="8" min="3"
                                style="width: 80px; text-align: center; font-size: 1.25rem;">
                            <span style="font-size: 0.875rem; color: var(--text-muted);">추천: <b
                                    id="ai-rec-scenes">8</b>개 <span style="font-size:0.7rem;">(표지 1 + 본문 <b id="ai-rec-body-scenes">7</b>)</span></span>
                        </div>
                        <p style="font-size: 0.75rem; color: var(--text-muted); margin-top: 0.5rem;">※ 시리즈 분할은 스토리 생성 후 Tab 3에서 설정합니다.</p>
                    </div>
                </div>
            </div>

            <div class="actions" id="data-actions" style="display: none;">
                <button class="btn btn-secondary" onclick="goToStep(1)">← 이전</button>
                <div style="display: flex; gap: 0.75rem; flex-wrap: wrap;">
                    <button class="btn btn-primary" onclick="selectContentType('webtoon')" style="display: flex; align-items: center; gap: 6px;">
                        <span style="font-size: 1.2rem;">📖</span> 웹툰용 스토리 만들기
                    </button>
                    <button class="btn btn-secondary" onclick="selectContentType('carousel')" style="display: flex; align-items: center; gap: 6px; border-color: #f59e0b; color: #f59e0b;">
                        <span style="font-size: 1.2rem;">🎠</span> 캐러셀 바로가기
                    </button>
                    <button class="btn btn-secondary" onclick="selectContentType('cardnews')" style="display: flex; align-items: center; gap: 6px; border-color: #10b981; color: #10b981;">
                        <span style="font-size: 1.2rem;">📰</span> 카드뉴스 바로가기
                    </button>
                </div>
            </div>
        </div>

        <!-- Step 3: 스토리 및 프리셋 선택 -->
        <div class="step-content" id="step-3">
            <!-- 프리셋 선택 + 캐릭터 이름 영역 -->
            <div style="background: var(--bg-input); border: 2px solid var(--primary); border-radius: 12px; padding: 14px 16px; margin-bottom: 10px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <div style="display: flex; align-items: center; gap: 6px;">
                        <span style="font-size: 1.1rem;">🎨</span>
                        <label style="font-weight: 700; font-size: 0.9rem;">프리셋 선택</label>
                        <span id="story-preset-label" style="font-size: 0.7rem; color: var(--text-muted);">프리셋을 선택해주세요</span>
                    </div>
                    <div style="display: flex; gap: 6px;">
                        <button onclick="navigateToStep('preset')" class="btn btn-sm" style="padding:4px 10px; font-size:0.75rem; background:var(--bg-card); border:1px solid var(--border); color:var(--text); cursor:pointer; border-radius:6px;">프리셋 관리</button>
                    </div>
                </div>
                <!-- 컴팩트 프리셋 갤러리 -->
                <div id="story-preset-gallery" style="margin-bottom:10px; min-height:60px;">
                    <span style="font-size:0.78rem; color:var(--text-muted);">로딩 중...</span>
                </div>
                <div style="display:flex; align-items:center; gap:8px;">
                    <label style="font-size:0.78rem; color:var(--text-muted); white-space:nowrap;">캐릭터 이름:</label>
                    <input type="text" id="character-names-input"
                        value=""
                        placeholder="예: 유리, 민수 (쉼표 구분, 비우면 AI 자동 생성)"
                        style="flex:1; padding:7px 10px; font-size:0.83rem; border-radius:6px; border:1px solid var(--border); box-sizing:border-box; background:var(--bg-card); color:var(--text);">
                </div>
                <div style="font-size: 0.68rem; color: var(--text-muted); margin-top: 4px;">
                    프리셋 선택 시 캐릭터 이름이 자동 반영됩니다. 직접 수정도 가능합니다. 비워두면 AI가 자동 생성합니다.
                </div>
                <!-- 독백 모드 -->
                <div style="display:flex; align-items:center; gap:8px; margin-top:8px; padding:6px 10px; background:rgba(99,102,241,0.04); border-radius:8px; border:1px solid var(--border);">
                    <label style="display:flex; align-items:center; gap:5px; cursor:pointer; font-size:0.82rem; white-space:nowrap;">
                        <input type="checkbox" id="monologue-mode-check" onchange="onMonologueModeChange()">
                        <span>🎤 독백 모드</span>
                    </label>
                    <select id="monologue-char-select" style="display:none; padding:4px 8px; border-radius:6px; border:1px solid var(--border); font-size:0.8rem; background:var(--bg-card); flex:1;">
                        <option value="">캐릭터 선택...</option>
                    </select>
                    <span style="font-size:0.68rem; color:var(--text-muted);" id="monologue-hint">1인 캐릭터만 등장하는 독백 형식</span>
                </div>
            </div>

            <!-- 스토리 생성 시작 버튼 (프리셋 선택 후 클릭) -->
            <div id="btn-generate-story" style="display:block; margin-bottom:12px;">
                <button class="btn btn-primary" onclick="generateStory()" style="width:100%; padding:14px; font-size:1rem; font-weight:700; display:flex; align-items:center; justify-content:center; gap:8px;">
                    <span style="font-size:1.2rem;">✨</span> 스토리 생성 시작
                </button>
                <p style="font-size:0.72rem; color:var(--text-muted); text-align:center; margin-top:6px;">위에서 프리셋을 선택하고 캐릭터 이름을 확인한 후 버튼을 눌러주세요.</p>
            </div>

            <div class="loading" id="loading-story">
                <div class="spinner"></div>
                <div>맞춤형 스토리를 구성 중입니다...</div>
            </div>

            <div id="story-review-area" style="display: none;">
                <!-- 캐릭터 프로필 섹션 -->
                <div class="card">
                    <h2 class="card-title">👥 등장인물 프로필</h2>
                    <div id="character-profiles" style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                        <!-- Character Profile Cards will be injected here -->
                    </div>
                </div>

                <!-- 스토리 씬 섹션 -->
                <div class="card">
                    <div
                        style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                        <h2 class="card-title" style="margin-bottom: 0;">📖 씬 검토 및 규칙 확인</h2>
                        <div style="font-size: 0.75rem; color: var(--text-muted);" id="rule-status">대사 20자 / 말풍선 2개 준수 중
                        </div>
                    </div>
                    <!-- 시리즈 분할 설정 패널 -->
                    <div id="series-split-panel" style="display:none; background: linear-gradient(135deg, rgba(99,102,241,0.05), rgba(99,102,241,0.12)); border: 1.5px solid var(--primary); border-radius: 10px; padding: 1rem; margin-bottom: 1rem;">
                        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.75rem;">
                            <h3 style="margin:0; font-size:0.95rem;">📚 시리즈 분할 설정</h3>
                            <span style="font-size:0.75rem; color:var(--text-muted);" id="series-total-scenes-info"></span>
                        </div>
                        <div style="display:flex; align-items:center; gap:0.75rem; margin-bottom:0.75rem;">
                            <label style="font-size:0.85rem; font-weight:600; white-space:nowrap;">총 시리즈 수</label>
                            <input type="number" id="series-count-input" value="1" min="1" max="10"
                                style="width:60px; text-align:center; font-size:1rem; border:1px solid var(--border); border-radius:6px; padding:4px;"
                                onchange="onSeriesCountChange(this.value)">
                            <span style="font-size:0.8rem; color:var(--text-muted);">1 = 분할 안 함</span>
                        </div>
                        <!-- 편별 씬 배분 영역 (시리즈 2 이상일 때 표시) -->
                        <div id="series-episodes-config" style="display:none;"></div>
                        <!-- 유효성 결과 -->
                        <div id="series-validation-msg" style="display:none; margin-top:0.5rem; font-size:0.8rem; padding:6px 10px; border-radius:6px;"></div>
                    </div>

                    <div id="scenes-container">
                        <div class="empty-state" id="scenes-empty" style="text-align:center; padding:3rem 1rem; color:var(--text-muted);">
                            <div style="font-size:2.5rem; margin-bottom:0.75rem;">📝</div>
                            <div style="font-weight:600; margin-bottom:0.3rem;">아직 씬이 없습니다</div>
                            <div style="font-size:0.82rem;">AI가 스토리를 생성하면 씬이 여기에 표시됩니다</div>
                        </div>
                    </div>

                    <!-- 이미지 생성 컨트롤 바 (탭3 통합) -->
                    <div class="gen-control-bar" id="gen-control-bar" style="display:none;">
                        <div class="gen-bar-header">
                            <div style="display:flex; align-items:center; gap:8px;">
                                <span style="font-weight:700; font-size:0.9rem;">🎞️ 이미지 생성</span>
                                <span id="gen-status-text" style="font-size:0.8rem; color:var(--text-muted);">준비됨</span>
                            </div>
                            <div style="display:flex; align-items:center; gap:6px; font-size:0.78rem;">
                                <label>비율:</label>
                                <select id="gen-aspect-ratio" style="padding:2px 6px; border-radius:6px; border:1px solid var(--border); font-size:0.78rem; background:var(--bg-card);">
                                    <option value="1:1" selected>1:1</option>
                                    <option value="9:16">9:16</option>
                                    <option value="4:5">4:5</option>
                                </select>
                                <span id="gen-status-count" style="color:var(--primary); font-weight:600;">0/0</span>
                            </div>
                        </div>
                        <div style="display:flex; gap:6px; margin-bottom:0.4rem;" id="gen-control-buttons">
                            <button class="btn btn-primary" onclick="startImageGeneration()" id="btn-start-gen" style="flex:1; padding:8px; font-size:0.85rem; font-weight:600;">
                                🎨 전체 이미지 생성
                            </button>
                            <button class="btn btn-secondary" onclick="pauseGeneration()" id="btn-pause" style="padding:8px 12px; font-size:0.85rem;">⏸️</button>
                            <button class="btn" onclick="stopGeneration()" style="padding:8px 12px; font-size:0.85rem; background:var(--danger); color:#fff; border:none; border-radius:8px; cursor:pointer;">⏹️</button>
                        </div>
                        <div id="gen-status-sub" style="font-size:0.72rem; color:var(--text-muted); margin-bottom:4px;"></div>
                        <div class="gen-bar-progress">
                            <div class="gen-bar-fill" id="gen-progress-bar" style="width:0%;"></div>
                        </div>
                        <div id="image-actions" style="display:none; margin-top:0.5rem; gap:6px;">
                            <button class="btn btn-primary" onclick="goToStep(4)" style="flex:1; padding:8px; font-size:0.85rem;">
                                ✏️ 이미지 편집 →
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 스토리 저장/불러오기 (항상 표시) -->
            <div id="story-save-load" style="margin-top:1rem;">
                <div class="card" style="padding:0.75rem;">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.5rem;">
                        <span style="font-weight:700; font-size:0.85rem;">💾 스토리 저장 / 불러오기</span>
                        <button class="btn btn-secondary" onclick="toggleSavedStories()" style="font-size:0.7rem; padding:2px 8px;">저장 목록</button>
                    </div>
                    <!-- 저장 영역 (스토리가 있을 때만 표시) -->
                    <div id="story-save-area" style="display:none; margin-bottom:0.5rem;">
                        <div style="display:flex; gap:4px;">
                            <input type="text" id="story-save-name" placeholder="저장 이름 입력 (예: 건강팁_v2)" 
                                style="flex:1; border:1px solid var(--border); border-radius:6px; padding:4px 8px; font-size:0.82rem; background:var(--bg-card);"
                                onkeydown="if(event.key==='Enter') saveStoryManual();">
                            <button class="btn btn-primary" onclick="saveStoryManual()" style="font-size:0.75rem; padding:4px 12px; flex-shrink:0;">저장</button>
                        </div>
                    </div>
                    <!-- 저장 목록 (토글) -->
                    <div id="saved-stories-list" style="display:none; max-height:250px; overflow-y:auto;"></div>
                </div>
            </div>

            <div class="actions" id="story-actions" style="display: none;">
                <button class="btn btn-secondary" onclick="goToStep(2)">← 이전</button>
                <button class="btn btn-primary" onclick="goToEditFromStory()" id="btn-to-edit">이미지 편집 →</button>
            </div>
        </div>

        <!-- 프리셋 관리 탭 (워크플로우 바깥, 별도 관리) -->
        <div class="step-content" id="step-preset">
            <div class="card">
                <h2 class="card-title">🎨 프리셋 관리</h2>
                <p style="color:var(--text-muted); margin-bottom:1.5rem;">캐릭터 이름과 레퍼런스 이미지 3장(캐릭터/연출/스타일)을 묶어 프리셋으로 관리합니다. 프리셋을 만들면 스토리 탭에서 선택하여 사용할 수 있습니다.</p>

                <!-- 영역 A: 프리셋 갤러리 -->
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:1rem;">
                    <h3 style="margin:0; font-size:1.1rem;">저장된 프리셋</h3>
                    <button class="btn btn-primary btn-sm" onclick="startNewPreset()">+ 새 프리셋 만들기</button>
                </div>

                <div id="preset-gallery-grid" style="display:grid; grid-template-columns:repeat(4, 1fr); gap:10px; margin-bottom:1rem;">
                    <!-- JS가 채움 -->
                </div>

                <!-- 페이지네이션 -->
                <div id="preset-pagination" style="display:flex; justify-content:center; gap:1rem; align-items:center; margin-bottom:1.5rem;">
                    <button class="btn btn-sm btn-outline" onclick="prevPresetPage()">← 이전</button>
                    <span id="preset-page-indicator" style="font-size:0.85rem; color:var(--text-muted);">1 / 1</span>
                    <button class="btn btn-sm btn-outline" onclick="nextPresetPage()">다음 →</button>
                </div>

                <hr style="border-color:var(--border); margin:1.5rem 0;">

                <!-- 영역 B: 프리셋 편집 -->
                <div id="preset-editor" style="display:none;">
                    <h3 style="margin-bottom:1rem; font-size:1.1rem;" id="preset-editor-title">새 프리셋 만들기</h3>

                    <div class="settings-grid" style="margin-bottom:1.5rem;">
                        <div class="form-group">
                            <label>프리셋 이름</label>
                            <input type="text" id="preset-name-input" placeholder="예: 미미 스타일" style="padding:0.75rem;">
                        </div>
                        <div class="form-group">
                            <label>캐릭터 이름 (쉼표 구분)</label>
                            <input type="text" id="preset-char-names-input" value="" placeholder="예: 유리, 민수 (쉼표 구분)" style="padding:0.75rem;">
                        </div>
                    </div>

                    <!-- 순서 가이드 배너 -->
                    <div style="background:rgba(99,102,241,0.1); border:1px solid var(--primary); border-radius:8px; padding:12px 16px; margin-bottom:1.5rem; font-size:0.9rem;">
                        <strong>화풍 일관성 가이드:</strong> 1.캐릭터 → 2.연출 → 3.스타일 순서로 생성하면 AI가 이전 이미지를 참조하여 동일한 화풍을 유지합니다.
                    </div>

                    <!-- 3장 레퍼런스 카드 -->
                    <div style="display:grid; grid-template-columns:repeat(3, 1fr); gap:1rem; margin-bottom:1.5rem;">
                        <!-- 1. 캐릭터 레퍼런스 -->
                        <div class="card" style="padding:1rem; border:2px solid var(--border);" id="ref-card-character">
                            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.25rem;">
                                <span style="font-weight:700; font-size:0.95rem;">1. 캐릭터</span>
                                <span id="ref-status-character" style="font-size:0.75rem; padding:2px 8px; border-radius:4px; background:var(--bg-input); color:var(--text-muted);">미설정</span>
                            </div>
                            <p style="font-size:0.75rem; color:var(--text-muted); margin:0 0 0.5rem 0; line-height:1.3;">웹툰에 등장할 캐릭터의 외형·디자인. 전신·정면 포즈 권장. 예시 버튼으로 샘플 프롬프트를 불러올 수 있습니다.</p>
                            <div id="ref-preview-character" style="width:100%; aspect-ratio:1; background:var(--bg-input); border-radius:8px; display:flex; align-items:center; justify-content:center; margin-bottom:0.75rem; overflow:hidden; position:relative;">
                                <span style="color:var(--text-muted); font-size:0.8rem; text-align:center; padding:1rem;">프리뷰 영역<br><span style="font-size:0.7rem;">AI 생성 또는 파일 업로드 시 여기에 표시됩니다</span></span>
                            </div>
                            <input type="file" id="ref-upload-character" accept="image/*" style="display:none;" onchange="handleRefUpload('character', this)">
                            <textarea id="ref-prompt-character" rows="6" placeholder="캐릭터 설명 프롬프트..." style="width:100%; margin-bottom:0.5rem; font-size:0.85rem; padding:8px; border-radius:6px; border:1px solid var(--border); background:var(--bg-input); color:var(--text); resize:vertical;"></textarea>
                            <div style="display:flex; gap:0.5rem;">
                                <button class="btn btn-sm btn-outline" onclick="fillExamplePrompt('character')" style="flex:1; font-size:0.75rem; display:flex; align-items:center; justify-content:center; white-space:nowrap;">예시</button>
                                <button class="btn btn-sm btn-primary" onclick="generateRef('character')" style="flex:1; font-size:0.75rem; display:flex; align-items:center; justify-content:center; white-space:nowrap;">AI 생성</button>
                                <button class="btn btn-sm btn-outline" onclick="document.getElementById('ref-upload-character').click()" style="flex:1; font-size:0.75rem; display:flex; align-items:center; justify-content:center; white-space:nowrap;">📁 파일</button>
                            </div>
                        </div>

                        <!-- 2. 연출 레퍼런스 -->
                        <div class="card" style="padding:1rem; border:2px solid var(--border);" id="ref-card-method">
                            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.25rem;">
                                <span style="font-weight:700; font-size:0.95rem;">2. 연출</span>
                                <span id="ref-status-method" style="font-size:0.75rem; padding:2px 8px; border-radius:4px; background:var(--bg-input); color:var(--text-muted);">미설정</span>
                            </div>
                            <p style="font-size:0.75rem; color:var(--text-muted); margin:0 0 0.5rem 0; line-height:1.3;">구도, 카메라 앵글, 만화 연출 방식. 1번 캐릭터를 기반으로 연출 스타일을 정의합니다. 예시 버튼 활용 가능.</p>
                            <div id="ref-preview-method" style="width:100%; aspect-ratio:1; background:var(--bg-input); border-radius:8px; display:flex; align-items:center; justify-content:center; margin-bottom:0.75rem; overflow:hidden; position:relative;">
                                <span style="color:var(--text-muted); font-size:0.8rem; text-align:center; padding:1rem;">프리뷰 영역<br><span style="font-size:0.7rem;">AI 생성 또는 파일 업로드 시 여기에 표시됩니다</span></span>
                            </div>
                            <input type="file" id="ref-upload-method" accept="image/*" style="display:none;" onchange="handleRefUpload('method', this)">
                            <textarea id="ref-prompt-method" rows="6" placeholder="연출/구도 프롬프트..." style="width:100%; margin-bottom:0.5rem; font-size:0.85rem; padding:8px; border-radius:6px; border:1px solid var(--border); background:var(--bg-input); color:var(--text); resize:vertical;"></textarea>
                            <div style="display:flex; gap:0.5rem;">
                                <button class="btn btn-sm btn-outline" onclick="fillExamplePrompt('method')" style="flex:1; font-size:0.75rem; display:flex; align-items:center; justify-content:center; white-space:nowrap;">예시</button>
                                <button class="btn btn-sm btn-primary" onclick="generateRef('method')" style="flex:1; font-size:0.75rem; display:flex; align-items:center; justify-content:center; white-space:nowrap;">AI 생성</button>
                                <button class="btn btn-sm btn-outline" onclick="document.getElementById('ref-upload-method').click()" style="flex:1; font-size:0.75rem; display:flex; align-items:center; justify-content:center; white-space:nowrap;">📁 파일</button>
                            </div>
                        </div>

                        <!-- 3. 스타일 레퍼런스 -->
                        <div class="card" style="padding:1rem; border:2px solid var(--border);" id="ref-card-style">
                            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.25rem;">
                                <span style="font-weight:700; font-size:0.95rem;">3. 스타일</span>
                                <span id="ref-status-style" style="font-size:0.75rem; padding:2px 8px; border-radius:4px; background:var(--bg-input); color:var(--text-muted);">미설정</span>
                            </div>
                            <p style="font-size:0.75rem; color:var(--text-muted); margin:0 0 0.5rem 0; line-height:1.3;">화풍, 색감, 선화 스타일. 캐릭터와 연출을 참고해 전체 분위기를 정의합니다. 예시 버튼 활용 가능.</p>
                            <div id="ref-preview-style" style="width:100%; aspect-ratio:1; background:var(--bg-input); border-radius:8px; display:flex; align-items:center; justify-content:center; margin-bottom:0.75rem; overflow:hidden; position:relative;">
                                <span style="color:var(--text-muted); font-size:0.8rem; text-align:center; padding:1rem;">프리뷰 영역<br><span style="font-size:0.7rem;">AI 생성 또는 파일 업로드 시 여기에 표시됩니다</span></span>
                            </div>
                            <input type="file" id="ref-upload-style" accept="image/*" style="display:none;" onchange="handleRefUpload('style', this)">
                            <textarea id="ref-prompt-style" rows="6" placeholder="화풍/스타일 프롬프트..." style="width:100%; margin-bottom:0.5rem; font-size:0.85rem; padding:8px; border-radius:6px; border:1px solid var(--border); background:var(--bg-input); color:var(--text); resize:vertical;"></textarea>
                            <div style="display:flex; gap:0.5rem;">
                                <button class="btn btn-sm btn-outline" onclick="fillExamplePrompt('style')" style="flex:1; font-size:0.75rem; display:flex; align-items:center; justify-content:center; white-space:nowrap;">예시</button>
                                <button class="btn btn-sm btn-primary" onclick="generateRef('style')" style="flex:1; font-size:0.75rem; display:flex; align-items:center; justify-content:center; white-space:nowrap;">AI 생성</button>
                                <button class="btn btn-sm btn-outline" onclick="document.getElementById('ref-upload-style').click()" style="flex:1; font-size:0.75rem; display:flex; align-items:center; justify-content:center; white-space:nowrap;">📁 파일</button>
                            </div>
                        </div>
                    </div>

                    <!-- AI 생성 로딩 표시 -->
                    <div id="ref-gen-loading" style="display:none; text-align:center; padding:1rem; background:var(--bg-input); border-radius:8px; margin-bottom:1rem;">
                        <div class="spinner" style="margin:0 auto 0.5rem;"></div>
                        <span id="ref-gen-loading-text" style="color:var(--text-muted);">AI가 이미지를 생성하고 있습니다...</span>
                    </div>

                    <!-- 테스트 생성 결과 영역 -->
                    <div id="preset-test-result" style="display:none; margin-bottom:1rem;">
                        <h4 style="margin-bottom:0.5rem;">테스트 생성 결과</h4>
                        <div id="preset-test-image" style="max-width:400px; border-radius:8px; overflow:hidden;"></div>
                    </div>

                    <!-- 하단 액션 버튼 -->
                    <div style="display:flex; gap:1rem; justify-content:flex-end;">
                        <button class="btn btn-outline" onclick="testPresetGeneration()">테스트 생성</button>
                        <button class="btn btn-primary" onclick="saveCurrentPreset()">프리셋 저장</button>
                    </div>
                </div>
            </div>

            <div class="actions">
                <button class="btn btn-secondary" onclick="navigateToStep(1)">← 워크플로우로</button>
            </div>
        </div>

        <!-- Step 4: 이미지 생성 (기존 step-5가 step-4로 이동, 비율 설정 통합) -->
        <!-- Step 4: 말풍선 & 대사 편집 -->
        <div class="step-content" id="step-4">
            <div class="card" style="padding: 1.25rem;">
                <h2 class="card-title" style="margin-bottom: 0.25rem;">💬 말풍선 & 대사 편집</h2>
                <p class="card-desc" style="margin-bottom: 1rem; font-size: 0.85rem; color: var(--text-muted);">
                    원본 이미지를 건드리지 않는 비파괴 편집. 대사 수정, 위치 변경, 스타일 변경이 자유롭습니다.
                </p>

                <!-- ═══ 씬 네비게이션 ═══ -->
                <div style="display: flex; align-items: center; justify-content: center; gap: 0.75rem; margin-bottom: 1rem; flex-wrap: wrap;">
                    <button class="btn btn-secondary" onclick="bubbleNav(-1)" id="bubble-prev-btn" style="padding: 8px 16px; font-size: 1.1rem;">←</button>
                    <span style="font-weight: 700; font-size: 1.1rem;" id="bubble-scene-indicator">씬 1 / 7</span>
                    <button class="btn btn-secondary" onclick="bubbleNav(1)" id="bubble-next-btn" style="padding: 8px 16px; font-size: 1.1rem;">→</button>
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <label style="font-size: 0.8rem;">말풍선 전체</label>
                        <input type="checkbox" id="bubble-show-all" checked onchange="toggleShowAll()">
                    </div>
                    <button class="btn btn-secondary" onclick="deleteSceneFromEditor()" id="bubble-delete-scene-btn"
                        style="padding: 4px 10px; font-size: 0.75rem; color: var(--danger); border-color: var(--danger);" title="현재 씬 삭제">
                        🗑 씬 삭제
                    </button>
                </div>

                <!-- ═══ 메인 편집 영역 (2컬럼) ═══ -->
                <div style="display: grid; grid-template-columns: 1fr 340px; gap: 1.25rem; min-height: 500px;" id="bubble-edit-main">

                    <!-- ★ 왼쪽: 이미지 + CSS 말풍선 오버레이 (실시간 프리뷰) ★ -->
                    <div style="position: relative; background: #1a1a2e; border-radius: 10px; overflow: hidden; display: flex; align-items: center; justify-content: center;">
                        <div id="bubble-preview-container" style="position: relative; width: 100%; max-width: 480px; aspect-ratio: 4/5;">
                            <img id="bubble-preview-img" src="" alt="씬 이미지"
                                 style="width: 100%; height: 100%; object-fit: contain; border-radius: 8px;">
                            <!-- CSS 말풍선 오버레이 레이어 (JS로 동적 생성 — 드래그 가능) -->
                            <div id="bubble-overlay-layer" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; overflow: hidden;">
                            </div>
                        </div>
                    </div>

                    <!-- ★ 오른쪽: 편집 패널 ★ -->
                    <div style="display: flex; flex-direction: column; gap: 0.75rem; overflow-y: auto; max-height: 600px;">

                        <!-- 글로벌 설정 -->
                        <div style="background: var(--bg); border: 1px solid var(--border); border-radius: 8px; padding: 0.75rem;">
                            <div style="font-size: 0.75rem; font-weight: 700; margin-bottom: 0.4rem; color: var(--text-muted);">⚙️ 전체 설정</div>
                            <div style="display: flex; gap: 0.4rem; align-items: center; margin-bottom: 0.4rem; flex-wrap: wrap;">
                                <label style="font-size: 0.75rem; font-weight: 600;">폰트</label>
                                <select id="bubble-font-family" onchange="onGlobalSettingChange()" style="padding: 3px 6px; font-size: 0.75rem; flex:1; min-width:80px;">
                                    <option value="Nanum Gothic">나눔고딕</option>
                                    <option value="Do Hyeon">도현</option>
                                    <option value="Jua">주아</option>
                                    <option value="Gaegu">개구</option>
                                    <option value="Black Han Sans">블랙한산스</option>
                                </select>
                                <label style="font-size: 0.75rem; font-weight: 600;">모양</label>
                                <select id="bubble-global-shape" style="padding: 3px 6px; font-size: 0.75rem;">
                                    <option value="round">둥근</option>
                                    <option value="round-lg">큰둥근</option>
                                    <option value="square">사각</option>
                                    <option value="shout">강조</option>
                                    <option value="spike">외침</option>
                                    <option value="thought">생각</option>
                                    <option value="cloud">구름</option>
                                    <option value="whisper">속삭임</option>
                                </select>
                            </div>
                            <div style="display: flex; gap: 0.4rem; align-items: center; margin-bottom: 0.5rem;">
                                <label style="font-size: 0.75rem; font-weight: 600;">글자색</label>
                                <input type="color" id="bubble-global-text-color" value="#000000" style="width:24px; height:20px; border:none; padding:0; cursor:pointer;">
                                <label style="font-size: 0.75rem; font-weight: 600;">배경색</label>
                                <input type="color" id="bubble-global-bg-color" value="#FFFFFF" style="width:24px; height:20px; border:none; padding:0; cursor:pointer;">
                                <label style="font-size: 0.75rem; font-weight: 600; margin-left:4px;">
                                    <input type="checkbox" id="bubble-global-bold" style="margin-right:2px;"> 볼드
                                </label>
                            </div>
                            <button class="btn btn-secondary" onclick="applyGlobalToAll()" style="width:100%; font-size:0.75rem; padding:5px;">
                                🔄 위 설정을 현재 씬 전체 말풍선에 일괄 적용
                            </button>
                        </div>

                        <!-- 개별 말풍선 편집 카드 (JS로 생성) -->
                        <div id="bubble-edit-cards" style="display: flex; flex-direction: column; gap: 0.5rem;">
                            <!-- 동적 생성 -->
                        </div>

                        <!-- 말풍선 추가 / 되돌리기 버튼 -->
                        <div style="display: flex; gap: 0.5rem;">
                            <button class="btn btn-secondary" onclick="addNewBubble()" style="font-size: 0.8rem; padding: 6px; flex: 1;">
                                + 말풍선 추가
                            </button>
                            <button class="btn btn-secondary" onclick="undoBubbles()" style="font-size: 0.8rem; padding: 6px;" title="마지막 변경 되돌리기">
                                ↩ 되돌리기
                            </button>
                            <button class="btn btn-secondary" onclick="resetBubbles()" style="font-size: 0.8rem; padding: 6px; color: var(--danger);" title="초기 상태로 복원">
                                🔄 초기화
                            </button>
                        </div>
                    </div>
                </div>

                <!-- 톤 조절 UI 제거됨 -->
            </div>

            <!-- 하단 액션 -->
            <div class="actions" style="margin-top: 1rem; display: flex; justify-content: space-between; align-items: center;">
                <button class="btn btn-secondary" onclick="goToStep(3)">← 이전 (스토리)</button>
                <div style="display: flex; gap: 0.5rem;">
                    <button class="btn btn-secondary" onclick="exportWithBubbles()" id="bubble-export-btn">최종 이미지 내보내기</button>
                    <button class="btn btn-primary" onclick="proceedFromEditStage()">다음 단계 (캡션) →</button>
                </div>
            </div>
        </div>

        <!-- Step 5: 캡션 생성 + 최종 발행 -->
        <div class="step-content" id="step-5">
            <!-- 시리즈 선택 탭 (시리즈 2개 이상일 때만 표시) -->
            <div id="publish-series-tabs" style="display:none; margin-bottom:1rem;">
                <div style="display:flex; gap:0.5rem; flex-wrap:wrap;" id="publish-series-tab-btns"></div>
            </div>
            <div class="loading" id="loading-caption" style="display: none;">
                <div class="spinner"></div>
                <div>AI가 인스타그램 맞춤형 캡션을 생성하고 있습니다...</div>
            </div>

            <div id="caption-publish-area" style="display: grid; grid-template-columns: 1fr 380px; gap: 2rem;">
                <!-- Left: Instagram Mockup -->
                <div class="card"
                    style="padding: 0; overflow: hidden; background: #fff; color: #000; border-radius: 12px; border: 1px solid #dbdbdb;">
                    <div
                        style="padding: 12px; display: flex; align-items: center; gap: 10px; border-bottom: 1px solid #efefef;">
                        <div
                            style="width: 32px; height: 32px; border-radius: 50%; background: linear-gradient(45deg, #f09433, #e6683c, #dc2743, #cc2366, #bc1888); padding: 2px;">
                            <div
                                style="width: 100%; height: 100%; border-radius: 50%; background: #fff; display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: bold;">
                                TAX</div>
                        </div>
                        <span style="font-weight: 600; font-size: 14px;">tax_webtoon_pro</span>
                    </div>

                    <div id="insta-preview-carousel"
                        style="aspect-ratio: 1/1; background: #fafafa; position: relative;">
                        <!-- Preview Image will be here -->
                        <img id="insta-preview-img" src="" style="width: 100%; height: 100%; object-fit: cover;">
                        <div style="position: absolute; bottom: 10px; right: 10px; background: rgba(0,0,0,0.7); color: #fff; padding: 4px 8px; border-radius: 12px; font-size: 12px;"
                            id="insta-carousel-index">1 / 8</div>
                    </div>

                    <div style="padding: 12px;">
                        <div style="display: flex; gap: 15px; margin-bottom: 10px;">
                            <span>❤️</span> <span>💬</span> <span>✈️</span> <span style="margin-left: auto;">🔖</span>
                        </div>
                        <div style="font-weight: 600; font-size: 14px; margin-bottom: 5px;">좋아요 1,234개</div>
                        <div style="font-size: 14px; line-height: 1.4;">
                            <span style="font-weight: 600; margin-right: 5px;">tax_webtoon_pro</span>
                            <span id="insta-preview-caption-text">AI가 생성한 캡션이 이곳에 표시됩니다.</span>
                        </div>
                        <div style="color: #0095f6; font-size: 14px; margin-top: 5px;" id="insta-preview-hashtags">#해시태그
                            #웹툰</div>
                    </div>
                </div>

                <!-- Right: Content Review & Actions -->
                <div>
                    <div class="card" style="padding: 1.5rem;">
                        <h2 class="card-title" style="font-size: 1.25rem;">📝 캡션 및 태그 수정</h2>
                        <div class="form-group">
                            <label>🔥 훅 문장</label>
                            <input type="text" id="final-hook" oninput="updateInstaPreview()">
                        </div>
                        <div class="form-group">
                            <label>📝 본문 캡션</label>
                            <textarea id="final-body" rows="6" oninput="updateInstaPreview()"></textarea>
                        </div>
                        <div class="form-group">
                            <label>💡 전문가 Tip</label>
                            <input type="text" id="final-tip" oninput="updateInstaPreview()">
                        </div>
                        <div class="form-group">
                            <label>#️⃣ 해시태그</label>
                            <textarea id="final-hashtags" rows="2" oninput="updateInstaPreview()"></textarea>
                        </div>
                    </div>

                    <!-- 발행 대상 계정 정보 -->
                    <div id="publish-account-info" class="card" style="padding:0.75rem 1rem; margin-bottom:0.5rem; display:none;">
                        <div style="display:flex; align-items:center; gap:0.75rem;">
                            <div id="pub-ig-pic" style="width:36px; height:36px; border-radius:50%; background:var(--bg-input); overflow:hidden; flex-shrink:0; display:flex; align-items:center; justify-content:center;">
                                <span style="font-size:1.1rem;">📷</span>
                            </div>
                            <div style="flex:1;">
                                <div style="font-size:0.82rem; font-weight:600;" id="pub-ig-name">Instagram 계정 확인 중...</div>
                                <div style="font-size:0.72rem; color:var(--text-muted);" id="pub-ig-detail"></div>
                            </div>
                            <div style="display:flex; gap:0.4rem; align-items:center;">
                                <a id="pub-ig-link" href="#" target="_blank" style="display:none; font-size:0.72rem; color:white; background:linear-gradient(45deg,#f09433,#e6683c,#dc2743,#cc2366,#bc1888); padding:3px 8px; border-radius:4px; text-decoration:none; white-space:nowrap;">📸 Instagram 열기</a>
                                <a href="/settings" style="font-size:0.72rem; color:var(--primary); text-decoration:none; background:rgba(99,102,241,0.1); padding:3px 8px; border-radius:4px; border:1px solid rgba(99,102,241,0.2); white-space:nowrap;">⚙️ 설정</a>
                            </div>
                        </div>
                    </div>

                    <div class="card" style="padding: 1.5rem; background: var(--bg-input);">
                        <h3 style="font-size: 1rem; margin-bottom: 1rem;">🚀 발행 옵션</h3>
                        
                        <button class="btn btn-primary" onclick="publishToInstagram()"
                            style="width: 100%; margin-bottom: 0.5rem;">📸 인스타그램 즉시 발행</button>
                        
                        <!-- 예약 발행 -->
                        <div style="border:1px solid var(--border); border-radius:8px; padding:0.75rem; margin-bottom:0.5rem;">
                            <div style="display:flex; align-items:center; gap:0.5rem; margin-bottom:0.5rem;">
                                <label style="font-size:0.82rem; font-weight:600; white-space:nowrap;">⏰ 예약 발행</label>
                                <input type="datetime-local" id="schedule-datetime" 
                                    style="flex:1; padding:4px 8px; border:1px solid var(--border); border-radius:6px; font-size:0.8rem; background:var(--bg-card); color:var(--text);">
                            </div>
                            <button class="btn btn-secondary" onclick="schedulePublish()" style="width:100%; font-size:0.82rem;">
                                📅 예약 발행 등록
                            </button>
                        </div>
                        
                        <!-- 다음편에 계속 (시리즈 2편 이상일 때만) -->
                        <div id="tbc-option" style="display:none; border:1px solid var(--border); border-radius:8px; padding:0.75rem; margin-bottom:0.5rem;">
                            <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:0.4rem;">
                                <label style="font-size:0.82rem; font-weight:600;">🔄 다음편에 계속</label>
                                <label style="position:relative; display:inline-block; width:36px; height:20px; cursor:pointer;">
                                    <input type="checkbox" id="tbc-toggle" checked onchange="toggleToBeContinued()"
                                        style="opacity:0; width:0; height:0;">
                                    <span style="position:absolute;inset:0;background:var(--border);border-radius:10px;transition:.3s;"></span>
                                    <span id="tbc-slider" style="position:absolute;left:2px;top:2px;width:16px;height:16px;background:#fff;border-radius:50%;transition:.3s;"></span>
                                </label>
                            </div>
                            <select id="tbc-style" style="width:100%; padding:4px 8px; font-size:0.78rem; border:1px solid var(--border); border-radius:6px; background:var(--bg-card); color:var(--text);">
                                <option value="fade_overlay">하단 그라데이션</option>
                                <option value="badge">우측 하단 배지</option>
                                <option value="full_overlay">전체 오버레이</option>
                            </select>
                        </div>

                        <button class="btn btn-secondary" onclick="downloadSeriesImages()" style="width: 100%; margin-bottom: 0.5rem;">📥 이미지 다운로드</button>
                        <button class="btn btn-secondary" onclick="copyCaptionToClipboard()" style="width: 100%; margin-bottom: 0.5rem;">📋 캡션 전체 복사</button>
                        <button class="btn btn-secondary" onclick="saveCurrentProject()" style="width: 100%;">💾 프로젝트 저장</button>
                    </div>
                </div>
            </div>

            <div class="actions" style="margin-top: 2rem;">
                <button class="btn btn-secondary" onclick="goToStep(4)">← 이전 (편집)</button>
            </div>
        </div>

        <!-- ============================================ -->
        <!-- 캐러셀 전용 패널 (간소화 워크플로우) -->
        <!-- ============================================ -->
        <!-- 캐러셀 전용 패널 -->
        <!-- ============================================ -->
        <div class="step-content" id="step-carousel" style="display:none;">
            <div class="card">
                <h2 class="card-title">🎠 캐러셀 만들기</h2>
                <p class="card-desc">인스타그램 캐러셀(슬라이드형) 콘텐츠를 빠르게 제작합니다.</p>

                <!-- 스텝 인디케이터 (p3-6) -->
                <div id="carousel-step-indicator" style="display:flex; gap:0; margin-bottom:1.5rem; border-radius:8px; overflow:hidden; border:1px solid var(--border);">
                    <div class="content-step active" data-step="settings" data-type="carousel" onclick="showContentStep('carousel','settings')" style="flex:1; text-align:center; padding:8px; cursor:pointer; font-size:0.8rem; font-weight:600; background:var(--primary); color:#fff;">① 설정</div>
                    <div class="content-step" data-step="editor" data-type="carousel" onclick="showContentStep('carousel','editor')" style="flex:1; text-align:center; padding:8px; cursor:pointer; font-size:0.8rem; font-weight:600; background:var(--bg); color:var(--text-muted);">② 편집</div>
                    <div class="content-step" data-step="preview" data-type="carousel" onclick="showContentStep('carousel','preview')" style="flex:1; text-align:center; padding:8px; cursor:pointer; font-size:0.8rem; font-weight:600; background:var(--bg); color:var(--text-muted);">③ 미리보기</div>
                </div>

                <!-- 설정 패널 -->
                <div id="carousel-settings-panel" style="background: var(--bg); border: 1px solid var(--border); border-radius: 10px; padding: 1.25rem; margin-bottom: 1.5rem;">
                    <h3 style="font-size: 1rem; margin-bottom: 0.75rem;">⚙️ 캐러셀 설정</h3>

                    <!-- 색상 테마 프리셋 (p3-1) -->
                    <div style="margin-bottom: 1rem;">
                        <label style="font-size: 0.8rem; font-weight: 600; margin-bottom: 4px; display:block;">색상 테마</label>
                        <div id="carousel-color-themes" style="display:flex; gap:8px; flex-wrap:wrap;"></div>
                    </div>

                    <!-- 필수 설정 (p3-5) -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-bottom: 1rem;">
                        <div>
                            <label style="font-size: 0.8rem; font-weight: 600;">슬라이드 수</label>
                            <div style="display:flex; align-items:center; gap:4px;">
                                <button onclick="adjustCount('carousel',-1)" style="width:28px;height:28px;border:1px solid var(--border);border-radius:4px;cursor:pointer;background:var(--bg);">-</button>
                                <input type="number" id="carousel-slide-count" value="5" min="1" max="10" style="width:50px; text-align:center; padding:4px;">
                                <button onclick="adjustCount('carousel',1)" style="width:28px;height:28px;border:1px solid var(--border);border-radius:4px;cursor:pointer;background:var(--bg);">+</button>
                            </div>
                        </div>
                        <div>
                            <label style="font-size: 0.8rem; font-weight: 600;">템플릿</label>
                            <div id="carousel-template-cards" style="display:flex; gap:6px;"></div>
                        </div>
                    </div>

                    <!-- 비율 선택 (p1-5) -->
                    <div style="margin-bottom: 1rem;">
                        <label style="font-size: 0.8rem; font-weight: 600; margin-bottom: 4px; display:block;">비율</label>
                        <div style="display:flex; gap:6px;">
                            <button class="ratio-btn active" data-type="carousel" data-ratio="default" onclick="selectRatio('carousel','default')" style="padding:4px 12px; border:2px solid var(--primary); border-radius:6px; cursor:pointer; font-size:0.75rem; background:var(--primary); color:#fff;">1:1</button>
                            <button class="ratio-btn" data-type="carousel" data-ratio="4:5" onclick="selectRatio('carousel','4:5')" style="padding:4px 12px; border:2px solid var(--border); border-radius:6px; cursor:pointer; font-size:0.75rem; background:var(--bg);">4:5</button>
                            <button class="ratio-btn" data-type="carousel" data-ratio="9:16" onclick="selectRatio('carousel','9:16')" style="padding:4px 12px; border:2px solid var(--border); border-radius:6px; cursor:pointer; font-size:0.75rem; background:var(--bg);">9:16</button>
                        </div>
                    </div>

                    <!-- 고급 설정 (p3-5) -->
                    <details style="margin-bottom: 1rem;">
                        <summary style="cursor:pointer; font-size:0.85rem; font-weight:600; color:var(--text-muted);">고급 옵션 ▾</summary>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-top: 0.75rem;">
                        <div>
                            <label style="font-size: 0.8rem; font-weight: 600;">배경색</label>
                            <input type="color" id="carousel-bg-color" value="#FFFFFF" style="width:100%; height:36px; border:1px solid var(--border); border-radius:6px;">
                        </div>
                        <div>
                            <label style="font-size: 0.8rem; font-weight: 600;">글자색</label>
                            <input type="color" id="carousel-text-color" value="#111111" style="width:100%; height:36px; border:1px solid var(--border); border-radius:6px;">
                        </div>
                        <div>
                            <label style="font-size: 0.8rem; font-weight: 600;">강조색</label>
                            <input type="color" id="carousel-accent-color" value="#6366f1" style="width:100%; height:36px; border:1px solid var(--border); border-radius:6px;">
                        </div>
                        <div>
                            <label style="font-size: 0.8rem; font-weight: 600;">폰트</label>
                            <select id="carousel-font" style="width:100%; padding: 6px 10px;">
                                <option value="Nanum Gothic">나눔고딕</option>
                                <option value="Do Hyeon">도현</option>
                                <option value="Jua">주아</option>
                                <option value="Black Han Sans">블랙한산스</option>
                                    <option value="Nanum Pen Script">나눔펜</option>
                                    <option value="Gaegu">개구</option>
                                    <option value="Noto Sans KR">노토산스</option>
                                    <option value="Nanum Myeongjo">나눔명조</option>
                                    <option value="Gothic A1">고딕A1</option>
                                    <option value="Sunflower">선플라워</option>
                                    <option value="Poor Story">푸어스토리</option>
                            </select>
                        </div>
                            <div>
                                <label style="font-size: 0.8rem; font-weight: 600;">제목 크기</label>
                                <select id="carousel-title-size" style="width:100%; padding: 6px 10px;">
                                    <option value="large">큰</option>
                                    <option value="medium" selected>보통</option>
                                    <option value="small">작은</option>
                                </select>
                    </div>
                            <div>
                                <label style="font-size: 0.8rem; font-weight: 600;">여백</label>
                                <select id="carousel-spacing" style="width:100%; padding: 6px 10px;">
                                    <option value="compact">촘촘</option>
                                    <option value="normal" selected>보통</option>
                                    <option value="spacious">넉넉</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size: 0.8rem; font-weight: 600;">제목 강조</label>
                                <select id="carousel-title-accent" style="width:100%; padding: 6px 10px;">
                                    <option value="none">없음</option>
                                    <option value="underline">밑줄</option>
                                    <option value="highlight">형광펜</option>
                                    <option value="box">박스</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size: 0.8rem; font-weight: 600;">마지막 페이지</label>
                                <select id="carousel-last-page-type" style="width:100%; padding: 6px 10px;">
                                    <option value="cta">CTA (행동유도)</option>
                                    <option value="summary">요약</option>
                                    <option value="branding">브랜딩</option>
                                </select>
                            </div>
                            <div style="grid-column: span 2;">
                                <label style="font-size: 0.8rem; font-weight: 600;">
                                    <input type="checkbox" id="carousel-gradient-toggle" onchange="toggleGradient('carousel')"> 그래디언트 배경
                                </label>
                                <div id="carousel-gradient-options" style="display:none; margin-top:6px; display:none; gap:6px;">
                                    <input type="color" id="carousel-gradient-start" value="#667eea" style="height:30px;width:60px;border:1px solid var(--border);border-radius:4px;">
                                    <input type="color" id="carousel-gradient-end" value="#764ba2" style="height:30px;width:60px;border:1px solid var(--border);border-radius:4px;">
                                    <select id="carousel-gradient-dir" style="padding:4px 8px;">
                                        <option value="to bottom">상하</option>
                                        <option value="to right">좌우</option>
                                        <option value="135deg" selected>대각선</option>
                                    </select>
                                </div>
                            </div>
                            <div style="grid-column: span 2;">
                                <label style="font-size: 0.8rem; font-weight: 600;">로고/워터마크</label>
                                <input type="file" id="carousel-logo-upload" accept="image/*" onchange="uploadLogo('carousel')" style="font-size:0.8rem;">
                                <span id="carousel-logo-status" style="font-size:0.75rem; color:var(--text-muted);"></span>
                            </div>
                        </div>
                    </details>

                    <!-- 프리셋 저장/불러오기 (p1-6) -->
                    <div style="display:flex; gap:6px; margin-bottom:1rem;">
                        <select id="carousel-preset-select" style="flex:1; padding:6px 10px; font-size:0.8rem;">
                            <option value="">프리셋 선택...</option>
                        </select>
                        <button class="btn btn-secondary" onclick="savePreset('carousel')" style="font-size:0.8rem; padding:4px 12px;">저장</button>
                        <button class="btn btn-secondary" onclick="loadPreset('carousel')" style="font-size:0.8rem; padding:4px 12px;">불러오기</button>
                    </div>

                    <button class="btn btn-primary" onclick="generateCarouselSlides()" style="width: 100%;">
                        🎠 AI 슬라이드 텍스트 생성
                    </button>
                </div>

                <!-- 편집 패널 -->
                <div id="carousel-slides-editor" style="display:none; margin-bottom: 1.5rem;">
                    <h3 style="font-size: 1rem; margin-bottom: 0.75rem;">📝 슬라이드 텍스트 편집</h3>
                    <div id="carousel-slides-list" style="display: flex; flex-direction: column; gap: 0.75rem;"></div>
                    <div style="display:flex; gap:0.5rem; margin-top:1rem;">
                        <button class="btn btn-primary" onclick="renderCarouselImages()" style="flex:1;">🖼️ 이미지 렌더링</button>
                        <button class="btn btn-secondary" onclick="addContentItem('carousel')" style="padding:6px 14px;">+ 추가</button>
                    </div>
                </div>

                <!-- 미리보기 패널 -->
                <div id="carousel-preview" style="display:none;">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.75rem;">
                        <h3 style="font-size: 1rem;">🖼️ 미리보기</h3>
                        <div style="display:flex; gap:6px;">
                            <button class="view-toggle-btn" onclick="toggleContentView('carousel','grid')" title="그리드 보기" style="padding:4px 8px; border:1px solid var(--border); border-radius:4px; cursor:pointer; background:var(--bg);">▦</button>
                            <button class="view-toggle-btn active" onclick="toggleContentView('carousel','swipe')" title="스와이프 보기" style="padding:4px 8px; border:1px solid var(--primary); border-radius:4px; cursor:pointer; background:var(--primary); color:#fff;">◁▷</button>
                        </div>
                    </div>
                    <!-- 스와이프 뷰 (p3-7) -->
                    <div id="carousel-swipe-view" style="position:relative; overflow:hidden; border-radius:8px; border:1px solid var(--border);">
                        <div id="carousel-swipe-container" style="display:flex; transition: transform 0.3s ease;"></div>
                        <button onclick="swipeContent('carousel',-1)" style="position:absolute;top:50%;left:8px;transform:translateY(-50%);background:rgba(0,0,0,0.5);color:#fff;border:none;border-radius:50%;width:32px;height:32px;cursor:pointer;font-size:1rem;">◀</button>
                        <button onclick="swipeContent('carousel',1)" style="position:absolute;top:50%;right:8px;transform:translateY(-50%);background:rgba(0,0,0,0.5);color:#fff;border:none;border-radius:50%;width:32px;height:32px;cursor:pointer;font-size:1rem;">▶</button>
                        <div id="carousel-swipe-dots" style="text-align:center;padding:8px;"></div>
                    </div>
                    <!-- 그리드 뷰 (p3-8) -->
                    <div id="carousel-grid-view" style="display:none;">
                    <div id="carousel-preview-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 0.75rem;"></div>
                    </div>
                    <!-- 렌더링 진행률 (p3-11) -->
                    <div id="carousel-render-progress" style="display:none; margin-top:0.75rem;">
                        <div style="background:var(--border);border-radius:4px;height:6px;overflow:hidden;">
                            <div id="carousel-progress-bar" style="background:var(--primary);height:100%;width:0%;transition:width 0.3s;"></div>
                        </div>
                        <div id="carousel-progress-text" style="font-size:0.75rem;color:var(--text-muted);margin-top:4px;text-align:center;"></div>
                    </div>
                    <button class="btn btn-primary" onclick="renderCarouselImages()" style="margin-top: 1rem;">🔄 다시 렌더링</button>
                </div>

                <div id="carousel-status" style="display:none; margin-top: 1rem; padding: 10px; background: var(--bg-card); border-radius: 8px; font-size: 0.85rem;"></div>

                <!-- 캡션 & 발행 (p3-14, p3-15, p3-16) -->
                <div id="carousel-publish-area" style="display:none; margin-top: 1.5rem; background: var(--bg); border: 1px solid var(--border); border-radius: 10px; padding: 1.25rem;">
                    <h3 style="font-size: 1rem; margin-bottom: 0.75rem;">📝 캡션 & 발행</h3>
                    <div class="form-group">
                        <label>🔥 훅 문장</label>
                        <input type="text" id="carousel-hook" placeholder="캐러셀 첫 문장" style="width:100%;">
                    </div>
                    <div class="form-group" style="position:relative;">
                        <label>📝 캡션</label>
                        <textarea id="carousel-caption" rows="4" placeholder="인스타그램 캡션..." style="width:100%;"></textarea>
                        <button onclick="copyCaption('carousel')" style="position:absolute;top:0;right:0;background:none;border:none;cursor:pointer;font-size:0.8rem;color:var(--primary);" title="클립보드 복사">📋 복사</button>
                    </div>
                    <div class="form-group">
                        <label>#️⃣ 해시태그</label>
                        <textarea id="carousel-hashtags" rows="2" placeholder="#웹툰 #정보 #꿀팁" style="width:100%;"></textarea>
                    </div>
                    <div style="display: flex; gap: 0.5rem; flex-wrap:wrap;">
                        <button class="btn btn-primary" onclick="generateCarouselCaption()" style="flex:1;">✨ AI 캡션 생성</button>
                        <button class="btn btn-secondary" onclick="downloadCarouselImages()" style="flex:1;">📥 ZIP 다운로드</button>
                        <button class="btn btn-secondary" onclick="publishContentToInstagram('carousel')" style="flex:1; border-color:#E1306C; color:#E1306C;">📸 인스타 발행</button>
                    </div>
                </div>
            </div>
            <div class="actions" style="margin-top: 2rem;">
                <button class="btn btn-secondary" onclick="exitCarouselMode()">← 자료 수집으로 돌아가기</button>
            </div>
        </div>

        <!-- ============================================ -->
        <!-- 카드뉴스 전용 패널 -->
        <!-- ============================================ -->
        <div class="step-content" id="step-cardnews" style="display:none;">
            <div class="card">
                <h2 class="card-title">📰 카드뉴스 만들기</h2>
                <p class="card-desc">인스타그램 카드뉴스를 빠르게 제작합니다. (4:5 세로형)</p>

                <!-- 스텝 인디케이터 (p3-6) -->
                <div id="cardnews-step-indicator" style="display:flex; gap:0; margin-bottom:1.5rem; border-radius:8px; overflow:hidden; border:1px solid var(--border);">
                    <div class="content-step active" data-step="settings" data-type="cardnews" onclick="showContentStep('cardnews','settings')" style="flex:1; text-align:center; padding:8px; cursor:pointer; font-size:0.8rem; font-weight:600; background:var(--primary); color:#fff;">① 설정</div>
                    <div class="content-step" data-step="editor" data-type="cardnews" onclick="showContentStep('cardnews','editor')" style="flex:1; text-align:center; padding:8px; cursor:pointer; font-size:0.8rem; font-weight:600; background:var(--bg); color:var(--text-muted);">② 편집</div>
                    <div class="content-step" data-step="preview" data-type="cardnews" onclick="showContentStep('cardnews','preview')" style="flex:1; text-align:center; padding:8px; cursor:pointer; font-size:0.8rem; font-weight:600; background:var(--bg); color:var(--text-muted);">③ 미리보기</div>
                </div>

                <!-- 설정 패널 -->
                <div id="cardnews-settings-panel" style="background: var(--bg); border: 1px solid var(--border); border-radius: 10px; padding: 1.25rem; margin-bottom: 1.5rem;">
                    <h3 style="font-size: 1rem; margin-bottom: 0.75rem;">⚙️ 카드뉴스 설정</h3>

                    <div style="margin-bottom: 1rem;">
                        <label style="font-size: 0.8rem; font-weight: 600; margin-bottom: 4px; display:block;">색상 테마</label>
                        <div id="cardnews-color-themes" style="display:flex; gap:8px; flex-wrap:wrap;"></div>
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-bottom: 1rem;">
                        <div>
                            <label style="font-size: 0.8rem; font-weight: 600;">카드 수</label>
                            <div style="display:flex; align-items:center; gap:4px;">
                                <button onclick="adjustCount('cardnews',-1)" style="width:28px;height:28px;border:1px solid var(--border);border-radius:4px;cursor:pointer;background:var(--bg);">-</button>
                                <input type="number" id="cardnews-card-count" value="5" min="1" max="10" style="width:50px; text-align:center; padding:4px;">
                                <button onclick="adjustCount('cardnews',1)" style="width:28px;height:28px;border:1px solid var(--border);border-radius:4px;cursor:pointer;background:var(--bg);">+</button>
                            </div>
                        </div>
                        <div>
                            <label style="font-size: 0.8rem; font-weight: 600;">템플릿</label>
                            <div id="cardnews-template-cards" style="display:flex; gap:6px;"></div>
                        </div>
                    </div>

                    <div style="margin-bottom: 1rem;">
                        <label style="font-size: 0.8rem; font-weight: 600; margin-bottom: 4px; display:block;">비율</label>
                        <div style="display:flex; gap:6px;">
                            <button class="ratio-btn" data-type="cardnews" data-ratio="1:1" onclick="selectRatio('cardnews','1:1')" style="padding:4px 12px; border:2px solid var(--border); border-radius:6px; cursor:pointer; font-size:0.75rem; background:var(--bg);">1:1</button>
                            <button class="ratio-btn active" data-type="cardnews" data-ratio="default" onclick="selectRatio('cardnews','default')" style="padding:4px 12px; border:2px solid var(--primary); border-radius:6px; cursor:pointer; font-size:0.75rem; background:var(--primary); color:#fff;">4:5</button>
                            <button class="ratio-btn" data-type="cardnews" data-ratio="9:16" onclick="selectRatio('cardnews','9:16')" style="padding:4px 12px; border:2px solid var(--border); border-radius:6px; cursor:pointer; font-size:0.75rem; background:var(--bg);">9:16</button>
                        </div>
                    </div>

                    <details style="margin-bottom: 1rem;">
                        <summary style="cursor:pointer; font-size:0.85rem; font-weight:600; color:var(--text-muted);">고급 옵션 ▾</summary>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-top: 0.75rem;">
                        <div>
                            <label style="font-size: 0.8rem; font-weight: 600;">배경색</label>
                            <input type="color" id="cardnews-bg-color" value="#1a1a2e" style="width:100%; height:36px; border:1px solid var(--border); border-radius:6px;">
                        </div>
                        <div>
                            <label style="font-size: 0.8rem; font-weight: 600;">글자색</label>
                            <input type="color" id="cardnews-text-color" value="#FFFFFF" style="width:100%; height:36px; border:1px solid var(--border); border-radius:6px;">
                        </div>
                        <div>
                            <label style="font-size: 0.8rem; font-weight: 600;">강조색</label>
                            <input type="color" id="cardnews-accent-color" value="#e94560" style="width:100%; height:36px; border:1px solid var(--border); border-radius:6px;">
                        </div>
                        <div>
                            <label style="font-size: 0.8rem; font-weight: 600;">폰트</label>
                            <select id="cardnews-font" style="width:100%; padding: 6px 10px;">
                                <option value="Nanum Gothic">나눔고딕</option>
                                <option value="Do Hyeon">도현</option>
                                <option value="Jua">주아</option>
                                <option value="Black Han Sans">블랙한산스</option>
                                    <option value="Nanum Pen Script">나눔펜</option>
                                    <option value="Gaegu">개구</option>
                                    <option value="Noto Sans KR">노토산스</option>
                                    <option value="Nanum Myeongjo">나눔명조</option>
                                    <option value="Gothic A1">고딕A1</option>
                                    <option value="Sunflower">선플라워</option>
                                    <option value="Poor Story">푸어스토리</option>
                            </select>
                        </div>
                            <div>
                                <label style="font-size: 0.8rem; font-weight: 600;">제목 크기</label>
                                <select id="cardnews-title-size" style="width:100%; padding: 6px 10px;">
                                    <option value="large">큰</option>
                                    <option value="medium" selected>보통</option>
                                    <option value="small">작은</option>
                                </select>
                    </div>
                            <div>
                                <label style="font-size: 0.8rem; font-weight: 600;">여백</label>
                                <select id="cardnews-spacing" style="width:100%; padding: 6px 10px;">
                                    <option value="compact">촘촘</option>
                                    <option value="normal" selected>보통</option>
                                    <option value="spacious">넉넉</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size: 0.8rem; font-weight: 600;">제목 강조</label>
                                <select id="cardnews-title-accent" style="width:100%; padding: 6px 10px;">
                                    <option value="none">없음</option>
                                    <option value="underline">밑줄</option>
                                    <option value="highlight">형광펜</option>
                                    <option value="box">박스</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size: 0.8rem; font-weight: 600;">마지막 페이지</label>
                                <select id="cardnews-last-page-type" style="width:100%; padding: 6px 10px;">
                                    <option value="cta">CTA (행동유도)</option>
                                    <option value="summary">요약</option>
                                    <option value="branding">브랜딩</option>
                                </select>
                            </div>
                            <div style="grid-column: span 2;">
                                <label style="font-size: 0.8rem; font-weight: 600;">
                                    <input type="checkbox" id="cardnews-gradient-toggle" onchange="toggleGradient('cardnews')"> 그래디언트 배경
                                </label>
                                <div id="cardnews-gradient-options" style="display:none; margin-top:6px; gap:6px;">
                                    <input type="color" id="cardnews-gradient-start" value="#667eea" style="height:30px;width:60px;border:1px solid var(--border);border-radius:4px;">
                                    <input type="color" id="cardnews-gradient-end" value="#764ba2" style="height:30px;width:60px;border:1px solid var(--border);border-radius:4px;">
                                    <select id="cardnews-gradient-dir" style="padding:4px 8px;">
                                        <option value="to bottom">상하</option>
                                        <option value="to right">좌우</option>
                                        <option value="135deg" selected>대각선</option>
                                    </select>
                                </div>
                            </div>
                            <div style="grid-column: span 2;">
                                <label style="font-size: 0.8rem; font-weight: 600;">로고/워터마크</label>
                                <input type="file" id="cardnews-logo-upload" accept="image/*" onchange="uploadLogo('cardnews')" style="font-size:0.8rem;">
                                <span id="cardnews-logo-status" style="font-size:0.75rem; color:var(--text-muted);"></span>
                            </div>
                        </div>
                    </details>

                    <div style="display:flex; gap:6px; margin-bottom:1rem;">
                        <select id="cardnews-preset-select" style="flex:1; padding:6px 10px; font-size:0.8rem;">
                            <option value="">프리셋 선택...</option>
                        </select>
                        <button class="btn btn-secondary" onclick="savePreset('cardnews')" style="font-size:0.8rem; padding:4px 12px;">저장</button>
                        <button class="btn btn-secondary" onclick="loadPreset('cardnews')" style="font-size:0.8rem; padding:4px 12px;">불러오기</button>
                    </div>

                    <button class="btn btn-primary" onclick="generateCardNewsCards()" style="width: 100%;">
                        📰 AI 카드 텍스트 생성
                    </button>
                </div>

                <!-- 편집 패널 -->
                <div id="cardnews-cards-editor" style="display:none; margin-bottom: 1.5rem;">
                    <h3 style="font-size: 1rem; margin-bottom: 0.75rem;">📝 카드 텍스트 편집</h3>
                    <div id="cardnews-cards-list" style="display: flex; flex-direction: column; gap: 0.75rem;"></div>
                    <div style="display:flex; gap:0.5rem; margin-top:1rem;">
                        <button class="btn btn-primary" onclick="renderCardNewsImages()" style="flex:1;">🖼️ 이미지 렌더링</button>
                        <button class="btn btn-secondary" onclick="addContentItem('cardnews')" style="padding:6px 14px;">+ 추가</button>
                    </div>
                </div>

                <!-- 미리보기 패널 -->
                <div id="cardnews-preview" style="display:none;">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.75rem;">
                        <h3 style="font-size: 1rem;">🖼️ 미리보기</h3>
                        <div style="display:flex; gap:6px;">
                            <button class="view-toggle-btn" onclick="toggleContentView('cardnews','grid')" title="그리드 보기" style="padding:4px 8px; border:1px solid var(--border); border-radius:4px; cursor:pointer; background:var(--bg);">▦</button>
                            <button class="view-toggle-btn active" onclick="toggleContentView('cardnews','swipe')" title="스와이프 보기" style="padding:4px 8px; border:1px solid var(--primary); border-radius:4px; cursor:pointer; background:var(--primary); color:#fff;">◁▷</button>
                        </div>
                    </div>
                    <div id="cardnews-swipe-view" style="position:relative; overflow:hidden; border-radius:8px; border:1px solid var(--border);">
                        <div id="cardnews-swipe-container" style="display:flex; transition: transform 0.3s ease;"></div>
                        <button onclick="swipeContent('cardnews',-1)" style="position:absolute;top:50%;left:8px;transform:translateY(-50%);background:rgba(0,0,0,0.5);color:#fff;border:none;border-radius:50%;width:32px;height:32px;cursor:pointer;font-size:1rem;">◀</button>
                        <button onclick="swipeContent('cardnews',1)" style="position:absolute;top:50%;right:8px;transform:translateY(-50%);background:rgba(0,0,0,0.5);color:#fff;border:none;border-radius:50%;width:32px;height:32px;cursor:pointer;font-size:1rem;">▶</button>
                        <div id="cardnews-swipe-dots" style="text-align:center;padding:8px;"></div>
                    </div>
                    <div id="cardnews-grid-view" style="display:none;">
                    <div id="cardnews-preview-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 0.75rem;"></div>
                    </div>
                    <div id="cardnews-render-progress" style="display:none; margin-top:0.75rem;">
                        <div style="background:var(--border);border-radius:4px;height:6px;overflow:hidden;">
                            <div id="cardnews-progress-bar" style="background:var(--primary);height:100%;width:0%;transition:width 0.3s;"></div>
                        </div>
                        <div id="cardnews-progress-text" style="font-size:0.75rem;color:var(--text-muted);margin-top:4px;text-align:center;"></div>
                    </div>
                    <button class="btn btn-primary" onclick="renderCardNewsImages()" style="margin-top: 1rem;">🔄 다시 렌더링</button>
                </div>

                <div id="cardnews-status" style="display:none; margin-top: 1rem; padding: 10px; background: var(--bg-card); border-radius: 8px; font-size: 0.85rem;"></div>

                <div id="cardnews-publish-area" style="display:none; margin-top: 1.5rem; background: var(--bg); border: 1px solid var(--border); border-radius: 10px; padding: 1.25rem;">
                    <h3 style="font-size: 1rem; margin-bottom: 0.75rem;">📝 캡션 & 발행</h3>
                    <div class="form-group">
                        <label>🔥 훅 문장</label>
                        <input type="text" id="cardnews-hook" placeholder="카드뉴스 첫 문장" style="width:100%;">
                    </div>
                    <div class="form-group" style="position:relative;">
                        <label>📝 캡션</label>
                        <textarea id="cardnews-caption" rows="4" placeholder="인스타그램 캡션..." style="width:100%;"></textarea>
                        <button onclick="copyCaption('cardnews')" style="position:absolute;top:0;right:0;background:none;border:none;cursor:pointer;font-size:0.8rem;color:var(--primary);" title="클립보드 복사">📋 복사</button>
                    </div>
                    <div class="form-group">
                        <label>#️⃣ 해시태그</label>
                        <textarea id="cardnews-hashtags" rows="2" placeholder="#카드뉴스 #정보 #꿀팁" style="width:100%;"></textarea>
                    </div>
                    <div style="display: flex; gap: 0.5rem; flex-wrap:wrap;">
                        <button class="btn btn-primary" onclick="generateCardNewsCaption()" style="flex:1;">✨ AI 캡션 생성</button>
                        <button class="btn btn-secondary" onclick="downloadCardNewsImages()" style="flex:1;">📥 ZIP 다운로드</button>
                        <button class="btn btn-secondary" onclick="publishContentToInstagram('cardnews')" style="flex:1; border-color:#E1306C; color:#E1306C;">📸 인스타 발행</button>
                    </div>
                </div>
            </div>
            <div class="actions" style="margin-top: 2rem;">
                <button class="btn btn-secondary" onclick="exitCardNewsMode()">← 자료 수집으로 돌아가기</button>
            </div>
        </div>

    </main>

    <script>
        // ── 토스트 알림 ──
        function showToast(message, type = 'info') {
            const colors = {
                success: '#10b981',
                error: '#ef4444',
                warning: '#f59e0b',
                info: '#6366f1'
            };
            const toast = document.createElement('div');
            toast.style.cssText = `position:fixed; bottom:24px; left:50%; transform:translateX(-50%); background:${colors[type] || colors.info}; color:#fff; padding:10px 20px; border-radius:8px; font-size:0.85rem; font-weight:600; z-index:99999; box-shadow:0 4px 12px rgba(0,0,0,0.3); transition:opacity 0.4s; max-width:90vw; text-align:center;`;
            toast.innerText = message;
            document.body.appendChild(toast);
            setTimeout(() => { toast.style.opacity = '0'; setTimeout(() => toast.remove(), 400); }, 3000);
        }

        // 에러 진단 토스트 — 서비스별 에러를 사용자 친화적으로 표시
        function showDiagnosticToast(diagnosis) {
            if (!diagnosis) return;
            const icons = {
                auth_expired: '🔑', auth_invalid: '🚫',
                credits: '💰', rate_limit: '⏱️',
                network: '🌐', server: '⚙️',
                not_configured: '📋', unknown: '❓'
            };
            const colors = {
                auth_expired: '#e74c3c', auth_invalid: '#e74c3c',
                credits: '#e67e22', rate_limit: '#f39c12',
                network: '#95a5a6', server: '#95a5a6',
                not_configured: '#3498db', unknown: '#7f8c8d'
            };
            const icon = icons[diagnosis.type] || '❓';
            const color = colors[diagnosis.type] || '#7f8c8d';
            const toast = document.createElement('div');
            toast.style.cssText = `position:fixed; top:80px; right:24px; z-index:99999; max-width:420px; animation:slideIn 0.3s ease;`;
            toast.innerHTML = `
                <div style="background:${color}; color:#fff; padding:16px 20px; border-radius:12px;
                            box-shadow:0 8px 32px rgba(0,0,0,0.3); font-size:0.88rem;">
                    <div style="font-weight:700; font-size:1rem; margin-bottom:8px;">
                        ${icon} ${diagnosis.message}
                    </div>
                    <div style="opacity:0.9; margin-bottom:12px; line-height:1.5;">
                        ${diagnosis.action}
                    </div>
                    ${diagnosis.detail ? `<details style="opacity:0.7; font-size:0.78rem; margin-bottom:8px;">
                        <summary style="cursor:pointer;">기술적 상세</summary>
                        <div style="margin-top:4px; word-break:break-all;">${diagnosis.detail}</div>
                    </details>` : ''}
                    <div style="display:flex; gap:8px;">
                        ${diagnosis.action_link ?
                            `<a href="${diagnosis.action_link}" style="background:rgba(255,255,255,0.2);
                             color:#fff; padding:6px 16px; border-radius:6px; text-decoration:none;
                             font-weight:600; font-size:0.82rem;">설정으로 이동</a>` : ''}
                        <button onclick="this.closest('div').parentElement.remove()"
                                style="background:rgba(255,255,255,0.15); color:#fff; border:none;
                                padding:6px 16px; border-radius:6px; cursor:pointer; font-size:0.82rem;">닫기</button>
                    </div>
                </div>
            `;
            document.body.appendChild(toast);
            setTimeout(() => { if (toast.parentElement) { toast.style.opacity = '0'; toast.style.transition = 'opacity 0.3s'; setTimeout(() => toast.remove(), 300); }}, 15000);
        }

        // fetch 응답에서 diagnosis 필드 자동 확인 유틸
        function handleApiResponse(data) {
            if (data && data.diagnosis) {
                showDiagnosticToast(data.diagnosis);
                return false; // 에러 있음
            }
            return true; // 정상
        }

        var currentStep = 1;
        var sessionId = null;
        var storyData = null;
        var collectedData = [];
        var characters = [];
        var selectedMode = 'auto'; // 'auto' or 'manual'

        // 추천 씬 수 계산 및 UI 업데이트 (표지 포함)
        function updateRecScenes() {
            const recScenes = Math.min(Math.max(Math.round(collectedData.length * 1.5), 6), 15);
            document.getElementById('total-scene-count').value = recScenes;
            document.getElementById('ai-rec-scenes').innerText = recScenes;
            const bodyEl = document.getElementById('ai-rec-body-scenes');
            if (bodyEl) bodyEl.innerText = recScenes - 1;
        }

        function selectMode(mode) {
            selectedMode = mode;
            document.querySelectorAll('.mode-card').forEach(c => {
                c.classList.toggle('selected', c.dataset.mode === mode);
            });

            if (mode === 'auto') {
                document.getElementById('keyword-input-area').style.display = 'block';
                document.getElementById('manual-input-area').style.display = 'none';
                document.getElementById('btn-start-next').innerText = '웹툰 제작 시작하기 🚀';
            } else {
                document.getElementById('keyword-input-area').style.display = 'none';
                document.getElementById('manual-input-area').style.display = 'block';
                document.getElementById('btn-start-next').innerText = '다음 단계: 스토리 직접 구성 →';
            }
        }

        // --- Step 1: 분야 감지 (Intelligent Start) ---
        async function detectField() {
            const keyword = document.getElementById('keyword').value.trim();
            const model = document.getElementById('ai-model-select').value;

            if (!keyword) {
                showToast('키워드를 입력해주세요.', 'warning');
                return;
            }

            const btn = document.querySelector('#step-1 .btn-secondary');
            const originalText = btn.innerText;
            btn.innerText = 'AI 분석 중...';
            btn.disabled = true;

            try {
                // 1. 세션 시작 및 필드 감지
                const res = await fetch('/api/workflow/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mode: 'auto', keyword, model })
                });
                const data = await res.json();
                sessionId = data.session_id;
                localStorage.setItem('lastSessionId', sessionId); // 세션 ID 저장

                // 2. 세션 정보 조회 (감지된 결과 확인)
                const sessionRes = await fetch(`/api/workflow/session/${sessionId}`);
                const session = await sessionRes.json();
                const info = session.field_info;

                // 3. Step 1 결과 UI 표시
                document.getElementById('smart-analysis-result').style.display = 'block';
                // 기존 시작 버튼 숨김
                document.getElementById('btn-start-next').style.display = 'none';

                // 값 바인딩
                document.getElementById('confirmed-field').value = info.field_code || 'GENERAL';
                document.getElementById('confirmed-year').innerText = info.target_year || new Date().getFullYear();
                document.getElementById('hidden-target-year').value = info.target_year || new Date().getFullYear();

                if (info.requires_legal_verification) {
                    document.getElementById('verification-needed-badge').style.display = 'flex';
                } else {
                    document.getElementById('verification-needed-badge').style.display = 'none';
                }

                btn.innerText = '다시 감지';
                btn.disabled = false;

            } catch (e) {
                console.error("Detect Field Error:", e);
                showToast('분야 감지 오류: ' + e.message, 'error');
                btn.innerText = originalText;
                btn.disabled = false;
            }
        }

        async function confirmAndStart() {
            // 사용자가 수정한 값 (혹은 AI 값)으로 확정
            const finalField = document.getElementById('confirmed-field').value;
            const finalYear = document.getElementById('hidden-target-year').value;

            // Step 1 -> Step 2
            navigateToStep(2);
            startDataCollection();
        }

        async function startWorkflow() {
            if (selectedMode === 'manual') {
                // 수동 모드: 사용자가 입력한 텍스트를 파싱
                const manualContent = document.getElementById('manual-script').value.trim();
                if (!manualContent) {
                    showToast('시나리오 또는 텍스트 내용을 입력해주세요.', 'warning');
                    return;
                }

                const btn = document.getElementById('btn-start-next');
                btn.innerText = '입력 내용 정리 중...';
                btn.disabled = true;

                try {
                    // 세션 생성 (수동 모드)
                    const startRes = await fetch('/api/workflow/start', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ mode: 'manual' })
                    });
                    const startData = await startRes.json();
                    sessionId = startData.session_id;
                    localStorage.setItem('lastSessionId', sessionId); // 세션 ID 저장

                    // Step 2로 이동
                    goToStep(2);

                    // 수동 모드 전용 데이터 수집 함수 호출
                    await collectManualData(manualContent);

                    btn.innerText = '다음 단계: 스토리 직접 구성 →';
                    btn.disabled = false;
                } catch (e) {
                    console.error(e);
                    showToast('수동 모드 시작 오류: ' + e.message, 'error');
                    btn.innerText = '다음 단계: 스토리 직접 구성 →';
                    btn.disabled = false;
                }
                return;
            }

            const keyword = document.getElementById('keyword').value.trim();
            if (!keyword) {
                showToast('키워드를 입력해주세요.', 'warning');
                return;
            }

            // [변경] 감지 단계 없이 바로 시작
            // 먼저 세션을 생성하고
            const model = document.getElementById('ai-model-select').value;
            try {
                const btn = document.getElementById('btn-start-next');
                btn.innerText = 'AI가 분석 및 시작 중...';
                btn.disabled = true;

                const res = await fetch('/api/workflow/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mode: 'auto', keyword, model })
                });
                const data = await res.json();

                if (!res.ok) {
                    throw new Error(data.detail || `세션 생성 실패 (${res.status})`);
                }

                sessionId = data.session_id;
                localStorage.setItem('lastSessionId', sessionId); // 세션 ID 저장

                btn.innerText = '웹툰 제작 시작하기 🚀';
                btn.disabled = false;

                // 바로 자료 수집 단계로 이동
                goToStep(2);
                await collectData();

            } catch (e) {
                console.error('워크플로우 시작 오류:', e);
                const btn = document.getElementById('btn-start-next');
                btn.innerText = '웹툰 제작 시작하기 🚀';
                btn.disabled = false;
                showToast('시작 오류: ' + e.message, 'error');
            }
        }

        // --- Step 2: 수동 모드 자료 파싱 ---
        async function collectManualData(content) {
            const loadingEl = document.getElementById('loading-data');
            const reviewArea = document.getElementById('data-review-area');
            const actionsEl = document.getElementById('data-actions');

            // 로딩 메시지 변경 (수동 모드용)
            loadingEl.querySelector('div:last-child').innerText = '입력하신 내용을 정리하고 있습니다...';
            loadingEl.style.display = 'block';
            reviewArea.style.display = 'none';
            actionsEl.style.display = 'none';

            try {
                const res = await fetch('/api/workflow/parse-manual-content', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        session_id: sessionId,
                        content: content
                    })
                });
                const data = await res.json();

                if (!res.ok) {
                    throw new Error(data.detail || '파싱 오류');
                }

                collectedData = data.items || [];

                renderDataItems();
                saveDataToStorage(); // localStorage에 저장

                // 씬 수 추천 (수동 모드)
                updateRecScenes();

                loadingEl.style.display = 'none';
                reviewArea.style.display = 'block';
                actionsEl.style.display = 'flex';
            } catch (e) {
                showToast('내용 파싱 오류: ' + e.message, 'error');
                loadingEl.style.display = 'none';
            }
        }

        // --- Step 2: 자료 수집 ---
        async function collectData() {
            const loadingEl = document.getElementById('loading-data');
            const reviewArea = document.getElementById('data-review-area');
            const actionsEl = document.getElementById('data-actions');

            loadingEl.style.display = 'block';
            loadingEl.innerHTML = '<div class="spinner"></div><p>AI가 자료를 수집하고 있습니다...</p>';
            reviewArea.style.display = 'none';
            actionsEl.style.display = 'none';

            try {
                const keyword = document.getElementById('keyword').value;
                const model = document.getElementById('ai-model-select').value;

                const res = await fetch('/api/workflow/collect-data', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ session_id: sessionId, keyword, model })
                });
                const data = await res.json();

                // 에러 응답 체크
                if (!res.ok) {
                    throw new Error(data.detail || `서버 오류 (${res.status})`);
                }

                collectedData = data.items || [];

                if (collectedData.length === 0) {
                    // 수집된 데이터가 없는 경우
                    loadingEl.style.display = 'none';
                    reviewArea.style.display = 'block';
                    reviewArea.innerHTML = `
                        <div style="text-align:center; padding:2rem; color:var(--text-muted);">
                            <p style="font-size:1.2rem; margin-bottom:1rem;">⚠️ 수집된 자료가 없습니다</p>
                            <p style="font-size:0.85rem; margin-bottom:1rem;">키워드를 더 구체적으로 입력하거나, 직접 항목을 추가해보세요.</p>
                            <div style="display:flex; gap:0.5rem; justify-content:center;">
                                <button class="btn btn-primary" onclick="collectData()" style="font-size:0.85rem;">🔄 다시 수집</button>
                                <button class="btn btn-secondary" onclick="addNewDataItem()" style="font-size:0.85rem;">+ 직접 추가</button>
                            </div>
                        </div>`;
                    actionsEl.style.display = 'flex';
                    return;
                }

                renderDataItems();
                saveDataToStorage(); // localStorage에 저장
                updateRecScenes();

                loadingEl.style.display = 'none';
                reviewArea.style.display = 'block';
                actionsEl.style.display = 'flex';
            } catch (e) {
                console.error('자료 수집 오류:', e);
                loadingEl.innerHTML = `
                    <div style="text-align:center; padding:1.5rem;">
                        <p style="color:var(--danger); font-size:1rem; margin-bottom:0.5rem;">❌ 자료 수집 실패</p>
                        <p style="font-size:0.85rem; color:var(--text-muted); margin-bottom:1rem;">${e.message}</p>
                        <div style="display:flex; gap:0.5rem; justify-content:center;">
                            <button class="btn btn-primary" onclick="collectData()" style="font-size:0.85rem;">🔄 다시 시도</button>
                            <button class="btn btn-secondary" onclick="addNewDataItem(); document.getElementById('loading-data').style.display='none'; document.getElementById('data-review-area').style.display='block'; document.getElementById('data-actions').style.display='flex';" style="font-size:0.85rem;">+ 직접 입력으로 시작</button>
                        </div>
                    </div>`;
            }
        }

        function renderDataItems() {
            const container = document.getElementById('data-container');
            container.innerHTML = collectedData.map((item, idx) => `
                <div class="char-card data-item" 
                     draggable="true"
                     ondragstart="handleDragStart(event, ${idx})"
                     ondragend="handleDragEnd(event)"
                     ondragover="handleDragOver(event, ${idx})"
                     ondrop="handleDrop(event, ${idx})"
                     style="cursor: grab; margin-bottom: 0.5rem; align-items: flex-start; flex-direction: column; transition: all 0.2s;">
                    <div style="display: flex; justify-content: space-between; width: 100%; align-items: center;">
                        <span style="font-weight: 600;" onclick="toggleDataBody(${idx})">
                            <span style="cursor: grab; margin-right: 0.5rem;">⋮⋮</span>
                            📄 ${item.title}
                        </span>
                        <div style="display: flex; gap: 0.5rem;">
                            <button class="btn btn-secondary" style="padding: 2px 8px; font-size: 0.75rem;" onclick="event.stopPropagation(); editData(${idx})">수정</button>
                            <button class="btn btn-secondary" style="padding: 2px 8px; font-size: 0.75rem;" onclick="event.stopPropagation(); deleteData(${idx})">삭제</button>
                        </div>
                    </div>
                    <div id="data-body-${idx}" onclick="event.stopPropagation();" style="display: block; margin-top: 0.5rem; font-size: 0.875rem; color: var(--text-muted); line-height: 1.5; border-top: 1px solid var(--border); padding-top: 0.5rem; width: 100%;">
                        ${item.content}
                    </div>
                </div>
            `).join('');
        }

        function toggleDataBody(idx) {
            const el = document.getElementById(`data-body-${idx}`);
            el.style.display = el.style.display === 'none' ? 'block' : 'none';
        }

        // === localStorage 데이터 저장/복원 ===
        function saveDataToStorage() {
            if (sessionId && collectedData.length > 0) {
                localStorage.setItem(`webtoon_data_${sessionId}`, JSON.stringify(collectedData));
                console.log('[Storage] 데이터 저장됨:', collectedData.length, '개 항목');
            }
        }

        function loadDataFromStorage() {
            if (sessionId) {
                const saved = localStorage.getItem(`webtoon_data_${sessionId}`);
                if (saved) {
                    collectedData = JSON.parse(saved);
                    console.log('[Storage] 데이터 복원됨:', collectedData.length, '개 항목');
                    return true;
                }
            }
            return false;
        }

        function clearDataFromStorage() {
            if (sessionId) {
                localStorage.removeItem(`webtoon_data_${sessionId}`);
            }
        }

        // === 정보 항목 수정 ===
        function editData(idx) {
            const item = collectedData[idx];
            const newTitle = prompt('제목을 수정하세요:', item.title);
            if (newTitle === null) return;

            const newContent = prompt('내용을 수정하세요:', item.content);
            if (newContent === null) return;

            collectedData[idx] = { title: newTitle, content: newContent };
            renderDataItems();
            saveDataToStorage();
        }

        // === 정보 항목 삭제 ===
        function deleteData(idx) {
            if (confirm(`"${collectedData[idx].title}" 항목을 삭제하시겠습니까?`)) {
                collectedData.splice(idx, 1);
                renderDataItems();
                saveDataToStorage();
                updateRecScenes();
            }
        }

        // === 정보 항목 추가 모달 ===
        function openAddDataModal() {
            const title = prompt('새 항목의 제목을 입력하세요:');
            if (!title) return;

            const content = prompt('새 항목의 내용을 입력하세요:');
            if (!content) return;

            collectedData.push({ title, content });
            renderDataItems();
            saveDataToStorage();
            updateRecScenes();
        }

        // === 직접 항목 추가 (수집 실패 시 호출) ===
        function addNewDataItem() {
            const title = prompt('새 항목의 제목을 입력하세요:');
            if (!title) return;
            const content = prompt('새 항목의 내용을 입력하세요:');
            if (!content) return;

            collectedData.push({ title, content });
            renderDataItems();
            saveDataToStorage();
            updateRecScenes();

            // UI 상태 보정: 로딩 숨기고 리뷰 영역 표시
            const loadingEl = document.getElementById('loading-data');
            const reviewArea = document.getElementById('data-review-area');
            const actionsEl = document.getElementById('data-actions');
            if (loadingEl) loadingEl.style.display = 'none';
            if (reviewArea) reviewArea.style.display = 'block';
            if (actionsEl) actionsEl.style.display = 'flex';
        }

        // === 드래그 앤 드롭 정렬 ===
        let draggedIdx = null;

        function handleDragStart(e, idx) {
            draggedIdx = idx;
            e.target.style.opacity = '0.5';
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragEnd(e) {
            e.target.style.opacity = '1';
            draggedIdx = null;
            // 모든 하이라이트 제거
            document.querySelectorAll('.data-item').forEach(el => {
                el.style.borderTop = '';
                el.style.borderBottom = '';
            });
        }

        function handleDragOver(e, idx) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';

            // 드롭 위치 표시
            const items = document.querySelectorAll('.data-item');
            items.forEach((el, i) => {
                el.style.borderTop = '';
                el.style.borderBottom = '';
                if (i === idx) {
                    if (draggedIdx < idx) {
                        el.style.borderBottom = '3px solid var(--primary)';
                    } else if (draggedIdx > idx) {
                        el.style.borderTop = '3px solid var(--primary)';
                    }
                }
            });
        }

        function handleDrop(e, targetIdx) {
            e.preventDefault();
            if (draggedIdx === null || draggedIdx === targetIdx) return;

            // 배열 순서 변경
            const [removed] = collectedData.splice(draggedIdx, 1);
            collectedData.splice(targetIdx, 0, removed);

            renderDataItems();
            saveDataToStorage();
            console.log('[Drag] 순서 변경 완료');
        }

        // 콘텐츠 타입 (webtoon | carousel | cardnews)
        let currentContentType = 'webtoon';

        function selectContentType(type) {
            currentContentType = type;

            if (type === 'webtoon') {
                confirmData();
            } else if (type === 'carousel') {
                showContentPanel('carousel');
            } else if (type === 'cardnews') {
                showContentPanel('cardnews');
            }
        }

        function showContentPanel(panel) {
            // 모든 step-content 숨기기
            document.querySelectorAll('.step-content').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.step-content').forEach(el => el.style.display = 'none');

            const target = document.getElementById(`step-${panel}`);
            if (target) {
                target.style.display = 'block';
                target.classList.add('active');
            }
        }

        function exitCarouselMode() {
            document.getElementById('step-carousel').style.display = 'none';
            goToStep(2);
        }

        function exitCardNewsMode() {
            document.getElementById('step-cardnews').style.display = 'none';
            goToStep(2);
        }

        async function confirmData() {
            goToStep(3);
            // 프리셋 선택 후 사용자가 직접 스토리 생성 버튼을 누르도록 대기
            // 스토리 생성 버튼 보이기, 생성 결과 영역 숨기기
            const genBtn = document.getElementById('btn-generate-story');
            if (genBtn) genBtn.style.display = 'block';
            document.getElementById('loading-story').style.display = 'none';
            document.getElementById('story-review-area').style.display = 'none';
            document.getElementById('story-actions').style.display = 'none';
            // 프리셋 갤러리 갱신
            if (typeof refreshStoryPresetSelector === 'function') refreshStoryPresetSelector();
        }

        // ═══════════════════════════════════════════
        // 캐러셀/카드뉴스 통합 JavaScript 엔진
        // ═══════════════════════════════════════════

        // 타입별 설정 (차이점만 정의)
        const contentConfig = {
            carousel: {
                apiPrefix: '/api/carousel',
                countParam: 'slide_count',
                itemsKey: 'slides',
                editParam: 'slide_index',
                editUrl: 'edit-slide',
                label: '슬라이드',
                countId: 'carousel-slide-count',
                titleLimit: 20, bodyLimit: 80,
            },
            cardnews: {
                apiPrefix: '/api/cardnews',
                countParam: 'card_count',
                itemsKey: 'cards',
                editParam: 'card_index',
                editUrl: 'edit-card',
                label: '카드',
                countId: 'cardnews-card-count',
                titleLimit: 15, bodyLimit: 100,
            }
        };

        // 상태 저장소
        const contentState = {
            carousel: { sessionId: null, items: [], currentSwipe: 0, selectedRatio: 'default', selectedTemplate: 'centered', logoPath: null },
            cardnews: { sessionId: null, items: [], currentSwipe: 0, selectedRatio: 'default', selectedTemplate: 'centered', logoPath: null },
        };

        // 색상 테마 프리셋 (p3-1)
        const colorThemes = [
            { name: '라이트', bg: '#FFFFFF', text: '#111111', accent: '#6366f1' },
            { name: '다크', bg: '#1a1a2e', text: '#FFFFFF', accent: '#e94560' },
            { name: '파스텔', bg: '#FFF0F5', text: '#333333', accent: '#FF69B4' },
            { name: '블루', bg: '#F0F4FF', text: '#1a1a2e', accent: '#3B82F6' },
            { name: '그린', bg: '#F0FFF4', text: '#1a1a2e', accent: '#22C55E' },
            { name: '오렌지', bg: '#FFF7ED', text: '#1a1a2e', accent: '#F97316' },
            { name: '골드', bg: '#1a1a2e', text: '#FFFFFF', accent: '#F59E0B' },
            { name: '모노', bg: '#FAFAFA', text: '#111111', accent: '#555555' },
        ];

        // 초기화
        function initContentPanels() {
            ['carousel', 'cardnews'].forEach(type => {
                // 색상 테마 버튼 생성
                const themeContainer = document.getElementById(`${type}-color-themes`);
                if (themeContainer) {
                    themeContainer.innerHTML = colorThemes.map((t, i) => `
                        <button onclick="applyColorTheme('${type}',${i})" title="${t.name}"
                            style="width:28px;height:28px;border-radius:50%;border:2px solid var(--border);cursor:pointer;background:linear-gradient(135deg,${t.bg} 50%,${t.accent} 50%);"></button>
                    `).join('');
                }
                // 템플릿 카드 생성 (p3-3)
                const tmplContainer = document.getElementById(`${type}-template-cards`);
                if (tmplContainer) {
                    const templates = [
                        { id: 'centered', label: '중앙', lines: 'center' },
                        { id: 'left-aligned', label: '왼쪽', lines: 'left' },
                        { id: 'highlight', label: '강조', lines: 'highlight' },
                    ];
                    tmplContainer.innerHTML = templates.map(t => `
                        <button onclick="selectTemplate('${type}','${t.id}')" data-tmpl="${t.id}"
                            class="tmpl-card ${t.id === 'centered' ? 'active' : ''}"
                            style="width:48px;height:48px;border:2px solid ${t.id === 'centered' ? 'var(--primary)' : 'var(--border)'};border-radius:6px;cursor:pointer;background:var(--bg);display:flex;flex-direction:column;align-items:${t.lines === 'left' ? 'flex-start' : 'center'};justify-content:center;padding:6px;gap:3px;"
                            title="${t.label}">
                            <div style="width:${t.lines === 'highlight' ? '70%' : '60%'};height:3px;background:${t.lines === 'highlight' ? 'var(--primary)' : '#999'};border-radius:1px;"></div>
                            <div style="width:80%;height:2px;background:#ccc;border-radius:1px;"></div>
                            <div style="width:50%;height:2px;background:#ccc;border-radius:1px;"></div>
                        </button>
                    `).join('');
                }
                // 프리셋 목록 로드
                loadPresetList(type);
            });
        }

        // DOM 준비 후 초기화
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initContentPanels);
        } else {
            initContentPanels();
        }

        // ── 공통 함수 ──

        function getContentSettings(type) {
            const gradientOn = document.getElementById(`${type}-gradient-toggle`)?.checked;
            let bgGradient = null;
            if (gradientOn) {
                const s = document.getElementById(`${type}-gradient-start`)?.value || '#667eea';
                const e = document.getElementById(`${type}-gradient-end`)?.value || '#764ba2';
                const d = document.getElementById(`${type}-gradient-dir`)?.value || '135deg';
                bgGradient = `linear-gradient(${d}, ${s}, ${e})`;
            }
            return {
                bg_color: document.getElementById(`${type}-bg-color`)?.value,
                text_color: document.getElementById(`${type}-text-color`)?.value,
                accent_color: document.getElementById(`${type}-accent-color`)?.value,
                font_family: document.getElementById(`${type}-font`)?.value || 'Nanum Gothic',
                template: contentState[type].selectedTemplate,
                title_size: document.getElementById(`${type}-title-size`)?.value || 'medium',
                spacing: document.getElementById(`${type}-spacing`)?.value || 'normal',
                title_accent: document.getElementById(`${type}-title-accent`)?.value || 'none',
                last_page_type: document.getElementById(`${type}-last-page-type`)?.value || 'cta',
                aspect_ratio: contentState[type].selectedRatio,
                bg_gradient: bgGradient,
            };
        }

        async function generateContent(type) {
            const cfg = contentConfig[type];
            const statusEl = document.getElementById(`${type}-status`);
            if (statusEl) { statusEl.style.display = 'block'; statusEl.innerHTML = `⏳ AI가 ${cfg.label} 텍스트를 생성 중...`; }

            const topic = collectedData.map(d => d.title || d.text || '').join(' ').substring(0, 500) || '일반 정보';
            const settings = getContentSettings(type);
            const countEl = document.getElementById(cfg.countId);
            const count = parseInt(countEl?.value || '5');

            const body = {
                topic,
                collected_data: JSON.stringify(collectedData).substring(0, 3000),
                [cfg.countParam]: count,
                ...settings,
            };

            try {
                const resp = await fetch(`${cfg.apiPrefix}/generate-${cfg.itemsKey === 'slides' ? 'slides' : 'cards'}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body),
                });
                const data = await resp.json();
                if (data.session_id) {
                    contentState[type].sessionId = data.session_id;
                    contentState[type].items = data[cfg.itemsKey];
                    renderContentEditor(type, data[cfg.itemsKey]);
                    showContentStep(type, 'editor');
                    if (statusEl) statusEl.innerHTML = `✅ ${data.total}개 ${cfg.label} 텍스트 생성 완료!`;
                } else {
                    if (statusEl) statusEl.innerHTML = `❌ 오류: ${data.detail || '알 수 없음'}`;
                }
            } catch (err) {
                if (statusEl) statusEl.innerHTML = `❌ 네트워크 오류: ${err.message}`;
            }
        }

        function renderContentEditor(type, items) {
            const cfg = contentConfig[type];
            const editorId = type === 'carousel' ? 'carousel-slides-editor' : 'cardnews-cards-editor';
            const listId = type === 'carousel' ? 'carousel-slides-list' : 'cardnews-cards-list';
            const editor = document.getElementById(editorId);
            const list = document.getElementById(listId);
            if (!editor || !list) return;
            editor.style.display = 'block';

            list.innerHTML = items.map((item, i) => `
                <div style="background: var(--bg-card); border: 1px solid var(--border); border-radius: 8px; padding: 1rem; position:relative;">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
                        <span style="font-size: 0.8rem; color: var(--text-muted);">${cfg.label} ${i + 1}</span>
                        <div style="display:flex; gap:4px;">
                            <button onclick="duplicateContentItem('${type}',${i})" title="복제" style="background:none;border:none;cursor:pointer;font-size:0.8rem;">📋</button>
                            <button onclick="deleteContentItem('${type}',${i})" title="삭제" style="background:none;border:none;cursor:pointer;font-size:0.8rem;">❌</button>
                        </div>
                    </div>
                    <div style="position:relative;">
                        <input type="text" id="${type}-title-${i}" value="${(item.title || '').replace(/"/g, '&quot;')}"
                            placeholder="제목" style="width: 100%; margin-bottom: 6px; font-weight: 700;"
                            oninput="updateCharCounter('${type}',${i},'title',${cfg.titleLimit})">
                        <span id="${type}-title-counter-${i}" style="position:absolute;right:8px;top:8px;font-size:0.7rem;color:var(--text-muted);">0/${cfg.titleLimit}</span>
                    </div>
                    <div style="position:relative;">
                        <textarea id="${type}-body-${i}" rows="2" placeholder="본문"
                            style="width: 100%; resize: vertical;"
                            oninput="updateCharCounter('${type}',${i},'body',${cfg.bodyLimit})">${item.body || ''}</textarea>
                        <span id="${type}-body-counter-${i}" style="position:absolute;right:8px;bottom:8px;font-size:0.7rem;color:var(--text-muted);">0/${cfg.bodyLimit}</span>
                    </div>
                </div>
            `).join('');

            // 초기 카운터 업데이트
            items.forEach((item, i) => {
                updateCharCounter(type, i, 'title', cfg.titleLimit);
                updateCharCounter(type, i, 'body', cfg.bodyLimit);
            });
        }

        async function renderContentImages(type) {
            const cfg = contentConfig[type];
            const state = contentState[type];
            if (!state.sessionId) { showToast(`${cfg.label} 텍스트를 먼저 생성해주세요.`, 'warning'); return; }

            const statusEl = document.getElementById(`${type}-status`);
            if (statusEl) { statusEl.style.display = 'block'; statusEl.innerHTML = `⏳ Playwright로 이미지 렌더링 중...`; }

            // 진행률 표시
            const progressEl = document.getElementById(`${type}-render-progress`);
            const progressBar = document.getElementById(`${type}-progress-bar`);
            const progressText = document.getElementById(`${type}-progress-text`);
            if (progressEl) progressEl.style.display = 'block';

            // 편집 텍스트 저장
            for (let i = 0; i < state.items.length; i++) {
                const titleEl = document.getElementById(`${type}-title-${i}`);
                const bodyEl = document.getElementById(`${type}-body-${i}`);
                if (titleEl) {
                    await fetch(`${cfg.apiPrefix}/${state.sessionId}/${cfg.editUrl}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ [cfg.editParam]: i, title: titleEl.value, body: bodyEl?.value || '' }),
                    });
                }
                // 진행률 업데이트 (저장 단계)
                if (progressBar) progressBar.style.width = `${((i + 1) / state.items.length * 30)}%`;
                if (progressText) progressText.textContent = `텍스트 저장 중... ${i + 1}/${state.items.length}`;
            }

            try {
                const settings = getContentSettings(type);
                const resp = await fetch(`${cfg.apiPrefix}/${state.sessionId}/render`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(settings),
                });
                if (progressBar) progressBar.style.width = '100%';
                if (progressText) progressText.textContent = '렌더링 완료!';

                const data = await resp.json();
                if (data.success) {
                    renderContentPreview(type, data.images);
                    showContentStep(type, 'preview');
                    if (statusEl) statusEl.innerHTML = `✅ ${data.total}개 ${cfg.label} 렌더링 완료!`;
                } else {
                    if (statusEl) statusEl.innerHTML = `❌ 렌더링 오류: ${data.detail || '알 수 없음'}`;
                }
            } catch (err) {
                if (statusEl) statusEl.innerHTML = `❌ 네트워크 오류: ${err.message}`;
            }
            // 3초 후 진행률 숨기기
            setTimeout(() => { if (progressEl) progressEl.style.display = 'none'; }, 3000);
        }

        function renderContentPreview(type, images) {
            const cfg = contentConfig[type];
            const preview = document.getElementById(`${type}-preview`);
            const grid = document.getElementById(`${type}-preview-grid`);
            const swipeContainer = document.getElementById(`${type}-swipe-container`);
            const dotsContainer = document.getElementById(`${type}-swipe-dots`);
            if (!preview) return;
            preview.style.display = 'block';
            contentState[type].currentSwipe = 0;

            const ts = Date.now();

            // 그리드 뷰
            if (grid) {
            grid.innerHTML = images.map((url, i) => `
                    <div style="border: 1px solid var(--border); border-radius: 8px; overflow: hidden; position:relative;" class="preview-card">
                        <img src="${url}?t=${ts}" style="width:100%; display:block;" alt="${cfg.label} ${i+1}">
                    <div style="text-align:center; padding:4px; font-size:0.75rem; color:var(--text-muted);">${i+1}/${images.length}</div>
                        <div class="hover-rerender" onclick="rerenderSingle('${type}',${i})"
                            style="position:absolute;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.4);display:none;align-items:center;justify-content:center;cursor:pointer;color:#fff;font-size:0.85rem;border-radius:8px;">
                            🔄 재렌더링
                        </div>
                </div>
            `).join('');
                // 호버 이벤트 (p3-12)
                grid.querySelectorAll('.preview-card').forEach(card => {
                    card.addEventListener('mouseenter', () => card.querySelector('.hover-rerender').style.display = 'flex');
                    card.addEventListener('mouseleave', () => card.querySelector('.hover-rerender').style.display = 'none');
                });
            }

            // 스와이프 뷰 (p3-7)
            if (swipeContainer) {
                swipeContainer.innerHTML = images.map((url, i) => `
                    <div style="min-width:100%;"><img src="${url}?t=${ts}" style="width:100%;display:block;" alt="${cfg.label} ${i+1}"></div>
                `).join('');
            }
            if (dotsContainer) {
                dotsContainer.innerHTML = images.map((_, i) => `
                    <span class="swipe-dot${i === 0 ? ' active' : ''}" onclick="goToSwipe('${type}',${i})"
                        style="display:inline-block;width:8px;height:8px;border-radius:50%;margin:0 3px;cursor:pointer;background:${i === 0 ? 'var(--primary)' : 'var(--border)'};">
                    </span>
                `).join('');
            }

            // 발행 패널 표시
            const pub = document.getElementById(`${type}-publish-area`);
            if (pub) pub.style.display = 'block';
        }

        async function generateContentCaption(type) {
            const cfg = contentConfig[type];
            const state = contentState[type];
            const hookEl = document.getElementById(`${type}-hook`);
            const capEl = document.getElementById(`${type}-caption`);
            const tagEl = document.getElementById(`${type}-hashtags`);
            if (!state.sessionId) return;

            try {
                const resp = await fetch(`${cfg.apiPrefix}/${state.sessionId}`);
                const session = await resp.json();
                const topic = session.topic || '';
                const itemTexts = (session[cfg.itemsKey] || []).map(it => it.title + ': ' + it.body).join('\n');

                const aiResp = await fetch('/api/workflow/generate-common-caption', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ topic, content: itemTexts, content_type: type }),
                });
                const data = await aiResp.json();
                if (data.hook && hookEl) hookEl.value = data.hook;
                if (data.body && capEl) capEl.value = data.body;
                if (data.hashtags && tagEl) tagEl.value = data.hashtags;
                showToast('캡션 생성 완료!', 'success');
            } catch (err) {
                showToast('캡션 생성 오류: ' + err.message, 'error');
            }
        }

        async function downloadContentImages(type) {
            const state = contentState[type];
            if (!state.sessionId) return showToast('렌더링된 이미지가 없습니다.', 'error');
            // ZIP 다운로드 (p3-15)
            window.open(`/api/content/${state.sessionId}/download`, '_blank');
        }

        // ── 래퍼 함수 (R5: 기존 onclick 호환) ──
        function generateCarouselSlides() { generateContent('carousel'); }
        function generateCardNewsCards() { generateContent('cardnews'); }
        function renderCarouselImages() { renderContentImages('carousel'); }
        function renderCardNewsImages() { renderContentImages('cardnews'); }
        function renderCarouselPreview(images) { renderContentPreview('carousel', images); }
        function renderCardNewsPreview(images) { renderContentPreview('cardnews', images); }
        function generateCarouselCaption() { generateContentCaption('carousel'); }
        function generateCardNewsCaption() { generateContentCaption('cardnews'); }
        function downloadCarouselImages() { downloadContentImages('carousel'); }
        function downloadCardNewsImages() { downloadContentImages('cardnews'); }

        // ── UI 헬퍼 함수 ──

        // 슬라이드 수 조절 (p1-1)
        function adjustCount(type, delta) {
            const cfg = contentConfig[type];
            const el = document.getElementById(cfg.countId);
            if (!el) return;
            let v = parseInt(el.value || '5') + delta;
            v = Math.max(1, Math.min(10, v));
            el.value = v;
        }

        // 색상 테마 적용 (p3-1)
        function applyColorTheme(type, idx) {
            const t = colorThemes[idx];
            const bg = document.getElementById(`${type}-bg-color`);
            const tx = document.getElementById(`${type}-text-color`);
            const ac = document.getElementById(`${type}-accent-color`);
            if (bg) bg.value = t.bg;
            if (tx) tx.value = t.text;
            if (ac) ac.value = t.accent;
        }

        // 템플릿 선택 (p3-3)
        function selectTemplate(type, tmplId) {
            contentState[type].selectedTemplate = tmplId;
            const container = document.getElementById(`${type}-template-cards`);
            if (container) {
                container.querySelectorAll('.tmpl-card').forEach(btn => {
                    const isSel = btn.dataset.tmpl === tmplId;
                    btn.style.borderColor = isSel ? 'var(--primary)' : 'var(--border)';
                    btn.classList.toggle('active', isSel);
                });
            }
        }

        // 비율 선택 (p1-5)
        function selectRatio(type, ratio) {
            contentState[type].selectedRatio = ratio;
            document.querySelectorAll(`.ratio-btn[data-type="${type}"]`).forEach(btn => {
                const isSel = btn.dataset.ratio === ratio;
                btn.style.borderColor = isSel ? 'var(--primary)' : 'var(--border)';
                btn.style.background = isSel ? 'var(--primary)' : 'var(--bg)';
                btn.style.color = isSel ? '#fff' : 'inherit';
                btn.classList.toggle('active', isSel);
            });
        }

        // 그래디언트 토글 (p3-2)
        function toggleGradient(type) {
            const on = document.getElementById(`${type}-gradient-toggle`)?.checked;
            const opts = document.getElementById(`${type}-gradient-options`);
            if (opts) opts.style.display = on ? 'flex' : 'none';
        }

        // 글자수 카운터 (p3-4)
        function updateCharCounter(type, idx, field, limit) {
            const el = document.getElementById(`${type}-${field}-${idx}`);
            const counter = document.getElementById(`${type}-${field}-counter-${idx}`);
            if (!el || !counter) return;
            const len = el.value.length;
            counter.textContent = `${len}/${limit}`;
            if (len > limit) {
                counter.style.color = '#ef4444';
                el.style.borderColor = '#ef4444';
            } else if (len > limit * 0.8) {
                counter.style.color = '#f59e0b';
                el.style.borderColor = '';
            } else {
                counter.style.color = '#22c55e';
                el.style.borderColor = '';
            }
        }

        // 스텝 인디케이터 (p3-6)
        function showContentStep(type, step) {
            const panels = {
                settings: `${type}-settings-panel`,
                editor: type === 'carousel' ? 'carousel-slides-editor' : 'cardnews-cards-editor',
                preview: `${type}-preview`,
            };
            // 모든 패널 숨기기/표시
            Object.entries(panels).forEach(([key, id]) => {
                const el = document.getElementById(id);
                if (el) el.style.display = key === step ? 'block' : 'none';
            });
            // 인디케이터 업데이트
            document.querySelectorAll(`#${type}-step-indicator .content-step`).forEach(el => {
                const isActive = el.dataset.step === step;
                el.style.background = isActive ? 'var(--primary)' : 'var(--bg)';
                el.style.color = isActive ? '#fff' : 'var(--text-muted)';
            });
        }

        // 스와이프 (p3-7)
        function swipeContent(type, dir) {
            const state = contentState[type];
            const container = document.getElementById(`${type}-swipe-container`);
            if (!container) return;
            const total = container.children.length;
            state.currentSwipe = Math.max(0, Math.min(total - 1, state.currentSwipe + dir));
            container.style.transform = `translateX(-${state.currentSwipe * 100}%)`;
            updateSwipeDots(type);
        }

        function goToSwipe(type, idx) {
            const container = document.getElementById(`${type}-swipe-container`);
            if (!container) return;
            contentState[type].currentSwipe = idx;
            container.style.transform = `translateX(-${idx * 100}%)`;
            updateSwipeDots(type);
        }

        function updateSwipeDots(type) {
            const dots = document.querySelectorAll(`#${type}-swipe-dots .swipe-dot`);
            dots.forEach((dot, i) => {
                dot.style.background = i === contentState[type].currentSwipe ? 'var(--primary)' : 'var(--border)';
            });
        }

        // 그리드/스와이프 뷰 토글 (p3-8)
        function toggleContentView(type, view) {
            const gridEl = document.getElementById(`${type}-grid-view`);
            const swipeEl = document.getElementById(`${type}-swipe-view`);
            if (gridEl) gridEl.style.display = view === 'grid' ? 'block' : 'none';
            if (swipeEl) swipeEl.style.display = view === 'swipe' ? 'block' : 'none';
        }

        // 아이템 추가/삭제/복제 (p3-9)
        async function addContentItem(type) {
            const state = contentState[type];
            if (!state.sessionId) return;
            try {
                const resp = await fetch(`/api/content/${state.sessionId}/add-item`, { method: 'POST' });
                const data = await resp.json();
                if (data.success) {
                    state.items.push(data.item);
                    renderContentEditor(type, state.items);
                    showToast(`${contentConfig[type].label} 추가됨`, 'success');
                }
            } catch (err) { showToast('추가 실패: ' + err.message, 'error'); }
        }

        async function deleteContentItem(type, idx) {
            const state = contentState[type];
            if (!state.sessionId || state.items.length <= 1) return showToast('최소 1개 필요합니다.', 'error');
            try {
                const resp = await fetch(`/api/content/${state.sessionId}/item/${idx}`, { method: 'DELETE' });
                const data = await resp.json();
                if (data.success) {
                    state.items.splice(idx, 1);
                    renderContentEditor(type, state.items);
                    showToast(`${contentConfig[type].label} 삭제됨`, 'success');
                }
            } catch (err) { showToast('삭제 실패: ' + err.message, 'error'); }
        }

        async function duplicateContentItem(type, idx) {
            const state = contentState[type];
            if (!state.sessionId || state.items.length >= 10) return showToast('최대 10개입니다.', 'error');
            try {
                const resp = await fetch(`/api/content/${state.sessionId}/duplicate/${idx}`, { method: 'POST' });
                const data = await resp.json();
                if (data.success) {
                    const orig = state.items[idx];
                    state.items.splice(idx + 1, 0, { title: orig.title, body: orig.body, page_number: '' });
                    renderContentEditor(type, state.items);
                    showToast(`${contentConfig[type].label} 복제됨`, 'success');
                }
            } catch (err) { showToast('복제 실패: ' + err.message, 'error'); }
        }

        // 개별 재렌더링 (p1-4, p3-12)
        async function rerenderSingle(type, idx) {
            const cfg = contentConfig[type];
            const state = contentState[type];
            if (!state.sessionId) return;

            const titleEl = document.getElementById(`${type}-title-${idx}`);
            const bodyEl = document.getElementById(`${type}-body-${idx}`);

            try {
                const resp = await fetch(`${cfg.apiPrefix}/${state.sessionId}/render-single`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        item_index: idx,
                        title: titleEl?.value || null,
                        body: bodyEl?.value || null,
                    }),
                });
                const data = await resp.json();
                if (data.success) {
                    showToast(`${cfg.label} ${idx + 1} 재렌더링 완료`, 'success');
                    // 이미지 갱신
                    const gridImgs = document.querySelectorAll(`#${type}-preview-grid img`);
                    if (gridImgs[idx]) gridImgs[idx].src = data.image + '?t=' + Date.now();
                    const swipeImgs = document.querySelectorAll(`#${type}-swipe-container img`);
                    if (swipeImgs[idx]) swipeImgs[idx].src = data.image + '?t=' + Date.now();
                }
            } catch (err) { showToast('재렌더링 실패: ' + err.message, 'error'); }
        }

        // 캡션 복사 (p3-14)
        async function copyCaption(type) {
            const capEl = document.getElementById(`${type}-caption`);
            const tagEl = document.getElementById(`${type}-hashtags`);
            if (!capEl) return;
            const text = (capEl.value || '') + '\n\n' + (tagEl?.value || '');
            try {
                await navigator.clipboard.writeText(text.trim());
                showToast('클립보드에 복사됨!', 'success');
            } catch { showToast('복사 실패', 'error'); }
        }

        // 로고 업로드 (p2-5)
        async function uploadLogo(type) {
            const input = document.getElementById(`${type}-logo-upload`);
            const status = document.getElementById(`${type}-logo-status`);
            if (!input?.files?.[0]) return;

            const formData = new FormData();
            formData.append('file', input.files[0]);

            try {
                const resp = await fetch('/api/content/upload-logo', { method: 'POST', body: formData });
                const data = await resp.json();
                if (data.success) {
                    contentState[type].logoPath = data.logo_path;
                    if (status) status.textContent = '업로드 완료';
                    showToast('로고 업로드 완료', 'success');
                } else {
                    if (status) status.textContent = data.detail || '실패';
                }
            } catch (err) {
                if (status) status.textContent = '업로드 오류';
            }
        }

        // 프리셋 저장/불러오기 (p1-6)
        async function loadPresetList(type) {
            try {
                const resp = await fetch('/api/content/presets');
                const data = await resp.json();
                const sel = document.getElementById(`${type}-preset-select`);
                if (sel && data.presets) {
                    sel.innerHTML = '<option value="">프리셋 선택...</option>' +
                        data.presets.map(p => `<option value="${p.name}">${p.name}</option>`).join('');
                }
            } catch {}
        }

        async function savePreset(type) {
            const name = prompt('프리셋 이름을 입력하세요:');
            if (!name) return;
            const settings = getContentSettings(type);
            settings.name = name;
            try {
                await fetch('/api/content/presets', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(settings),
                });
                showToast('프리셋 저장 완료', 'success');
                loadPresetList(type);
            } catch (err) { showToast('저장 실패', 'error'); }
        }

        async function loadPreset(type) {
            const sel = document.getElementById(`${type}-preset-select`);
            const name = sel?.value;
            if (!name) return showToast('프리셋을 선택하세요', 'error');
            try {
                const resp = await fetch('/api/content/presets');
                const data = await resp.json();
                const preset = data.presets.find(p => p.name === name);
                if (!preset) return;
                // 필드에 적용
                const fields = ['bg_color', 'text_color', 'accent_color', 'font_family', 'title_size', 'spacing', 'title_accent', 'last_page_type'];
                const idMap = { bg_color: 'bg-color', text_color: 'text-color', accent_color: 'accent-color', font_family: 'font', title_size: 'title-size', spacing: 'spacing', title_accent: 'title-accent', last_page_type: 'last-page-type' };
                fields.forEach(f => {
                    const el = document.getElementById(`${type}-${idMap[f]}`);
                    if (el && preset[f]) el.value = preset[f];
                });
                if (preset.template) selectTemplate(type, preset.template);
                if (preset.aspect_ratio) selectRatio(type, preset.aspect_ratio);
                showToast('프리셋 적용 완료', 'success');
            } catch (err) { showToast('불러오기 실패', 'error'); }
        }

        // 인스타그램 발행 (p3-16)
        async function publishContentToInstagram(type) {
            const state = contentState[type];
            if (!state.sessionId) return showToast('렌더링된 이미지가 없습니다.', 'error');
            if (!confirm('인스타그램에 발행합니다. 계속할까요?')) return;

            const capEl = document.getElementById(`${type}-caption`);
            const tagEl = document.getElementById(`${type}-hashtags`);
            const caption = ((capEl?.value || '') + '\n\n' + (tagEl?.value || '')).trim();

            try {
                // 세션에서 이미지 목록 가져오기
                const cfg = contentConfig[type];
                const sessResp = await fetch(`${cfg.apiPrefix}/${state.sessionId}`);
                const sessData = await sessResp.json();
                const images = sessData.rendered_images || [];

                if (!images.length) return showToast('렌더링된 이미지가 없습니다.', 'error');

                const resp = await fetch('/api/workflow/publish', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        session_id: state.sessionId,
                        caption: caption,
                        images: images,
                    }),
                });
                const data = await resp.json();
                if (data.success) {
                    showToast('인스타그램 발행 완료!', 'success');
                } else {
                    showToast('발행 실패: ' + (data.detail || data.error || '알 수 없음'), 'error');
                }
            } catch (err) {
                showToast('발행 오류: ' + err.message, 'error');
            }
        }

        // 키보드 좌우 화살표 스와이프 (p3-7)
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                const dir = e.key === 'ArrowLeft' ? -1 : 1;
                const activeType = document.getElementById('step-carousel')?.style.display !== 'none' ? 'carousel' :
                    document.getElementById('step-cardnews')?.style.display !== 'none' ? 'cardnews' : null;
                if (activeType) swipeContent(activeType, dir);
            }
        });

        // --- Step 3: 스토리 생성 ---
        async function generateStory() {
            const loadingEl = document.getElementById('loading-story');
            const reviewArea = document.getElementById('story-review-area');
            const actionsEl = document.getElementById('story-actions');
            const genStoryBtn = document.getElementById('btn-generate-story');

            // 생성 버튼 숨기고 로딩 표시
            if (genStoryBtn) genStoryBtn.style.display = 'none';
            loadingEl.style.display = 'block';
            reviewArea.style.display = 'none';
            actionsEl.style.display = 'none';

            const sceneCount = parseInt(document.getElementById('total-scene-count').value);

            try {
                const storyModel = document.getElementById('ai-model-select') ? document.getElementById('ai-model-select').value : 'gemini-3-flash-preview';
                const charNamesInput = document.getElementById('character-names-input');
                const charNames = charNamesInput ? charNamesInput.value.trim() : '';
                // collected_data를 안전하게 직렬화 (너무 큰 데이터 방지)
                let safeCollectedData = null;
                try {
                    if (collectedData && collectedData.length > 0) {
                        safeCollectedData = collectedData.map(item => ({
                            title: String(item.title || '').substring(0, 500),
                            content: String(item.content || item.text || '').substring(0, 2000)
                        }));
                    }
                } catch(cdErr) {
                    console.warn('collected_data 직렬화 실패, 서버 데이터 사용:', cdErr);
                }

                // 독백 모드 확인
                const monologueCheck = document.getElementById('monologue-mode-check');
                const monologueCharSelect = document.getElementById('monologue-char-select');
                const isMonologue = monologueCheck ? monologueCheck.checked : false;
                const monologueChar = (isMonologue && monologueCharSelect) ? monologueCharSelect.value : '';

                const res = await fetch('/api/workflow/generate-story', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        session_id: sessionId,
                        scene_count: sceneCount,
                        questioner_type: '일반인',
                        expert_type: '전문가',
                        model: storyModel,
                        character_names: charNames,
                        collected_data: safeCollectedData,
                        monologue_mode: isMonologue,
                        monologue_character: monologueChar
                    })
                });

                // 응답 체크 — JSON 파싱 전에 상태 확인
                if (!res.ok) {
                    let errMsg = `서버 오류 (${res.status})`;
                    try {
                        const errData = await res.json();
                        errMsg = errData.detail || errMsg;
                    } catch(_) {
                        // JSON 파싱 실패 시 텍스트로 시도
                        try { errMsg = await res.text(); } catch(__) {}
                    }
                    throw new Error(errMsg);
                }

                const data = await res.json();

                if (data.session_id) {
                    sessionId = data.session_id;
                    localStorage.setItem('lastSessionId', sessionId); // 세션 ID 저장 (안전장치)
                }

                storyData = data.story;

                // storyData가 없는 경우 처리
                if (!storyData) {
                    throw new Error('스토리 데이터를 받지 못했습니다. 다시 시도해주세요.');
                }

                characters = storyData.characters || [];

                renderCharacters();
                renderScenes(storyData.scenes || []);
                showSeriesPanel();

                loadingEl.style.display = 'none';
                reviewArea.style.display = 'block';
                actionsEl.style.display = 'flex';
            } catch (e) {
                console.error('스토리 생성 오류:', e);
                showToast('스토리 생성 오류: ' + e.message, 'error');
                loadingEl.style.display = 'none';
                // 실패 시 생성 버튼 다시 표시
                if (genStoryBtn) genStoryBtn.style.display = 'block';
            }
        }

        function renderCharacters() {
            const container = document.getElementById('character-profiles');
            container.innerHTML = characters.map((c, idx) => `
                <div class="char-card" style="position: relative;">
                    <div class="char-avatar">👤</div>
                    <div class="char-info">
                        <div class="char-name">${c.name} <span class="char-role">${c.role}</span></div>
                        <div style="font-size: 0.75rem; color: var(--text-muted);">${c.appearance}</div>
                    </div>
                    <button class="btn btn-secondary" style="position: absolute; top: 0.5rem; right: 0.5rem; padding: 2px 8px; font-size: 0.7rem;" onclick="editCharacter(${idx})">수정</button>
                </div>
            `).join('');
        }

        function editCharacter(idx) {
            const char = characters[idx];
            const newName = prompt('캐릭터 이름:', char.name);
            if (newName === null) return;

            const newRole = prompt('역할 (전문가/질문자/조력자):', char.role);
            if (newRole === null) return;

            const newAppearance = prompt('외모 묘사:', char.appearance);
            if (newAppearance === null) return;

            const oldName = char.name;
            const updatedName = newName || char.name;

            characters[idx] = {
                ...char,
                name: updatedName,
                role: newRole || char.role,
                appearance: newAppearance || char.appearance
            };

            // storyData도 업데이트
            if (storyData && storyData.characters) {
                storyData.characters[idx] = characters[idx];
            }

            // 이름이 변경된 경우, 모든 씬의 텍스트에서 캐릭터 이름 일괄 교체
            if (oldName !== updatedName && storyData && storyData.scenes) {
                const nameRegex = new RegExp(oldName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
                storyData.scenes.forEach(scene => {
                    // 씬 설명에서 이름 교체
                    if (scene.scene_description) {
                        scene.scene_description = scene.scene_description.replace(nameRegex, updatedName);
                    }
                    // 나레이션에서 이름 교체
                    if (scene.narration) {
                        scene.narration = scene.narration.replace(nameRegex, updatedName);
                    }
                    // 대사에서 화자 이름 및 대사 내용 교체
                    if (scene.dialogues) {
                        scene.dialogues.forEach(d => {
                            if (d.character === oldName) {
                                d.character = updatedName;
                            }
                            if (d.text) {
                                d.text = d.text.replace(nameRegex, updatedName);
                            }
                        });
                    }
                });
                // 씬 목록도 다시 렌더링
                renderScenes(storyData.scenes);
            }

            // 캐릭터 이름 입력란도 동기화
            const nameInput = document.getElementById('character-names-input');
            if (nameInput) {
                const currentNames = characters.map(c => c.name).join(', ');
                nameInput.value = currentNames;
            }

            renderCharacters();
            showToast(`캐릭터 "${updatedName}" 정보가 수정되었습니다`, 'success');
        }

        // ── 감정 목록 (한글) ──
        const EMOTION_OPTIONS = [
            '일반', '웃으며', '밝게', '진지하게', '놀라며', '화내며',
            '슬프게', '걱정하며', '당황하며', '자신있게', '속삭이며', '소리치며',
            '궁금해하며', '감탄하며', '고민하며', '장난스럽게', '뿌듯하게',
            '차분하게', '다급하게', '부끄러워하며'
        ];

        // 캐릭터 선택 드롭다운 HTML 생성
        function renderSpeakerSelect(sceneIdx, dialogueIdx, currentChar) {
            const chars = (storyData.characters || []).map(c => c.name || c);
            const id = dialogueIdx === -1
                ? `new-dialogue-char-${sceneIdx}`
                : '';
            const onChange = dialogueIdx === -1
                ? ''
                : `onchange="changeSpeaker(${sceneIdx}, ${dialogueIdx}, this.value)"`;
            let opts = chars.map(c => {
                const sel = (c === currentChar) ? ' selected' : '';
                return `<option value="${c}"${sel}>${c}</option>`;
            }).join('');
            // 새 대사 추가용일 때 첫번째 캐릭터 기본 선택
            return `<select ${id ? 'id="'+id+'"' : ''} ${onChange}
                style="font-weight:700; color:var(--primary); background:transparent; border:1px solid var(--primary); border-radius:8px; padding:2px 4px; font-size:0.75rem; cursor:pointer; flex-shrink:0; max-width:76px;"
                title="말하는 사람">${opts}</select>`;
        }

        // 감정 선택 드롭다운 HTML 생성
        function renderEmotionSelect(sceneIdx, dialogueIdx, currentEmotion) {
            const id = dialogueIdx === -1
                ? `new-dialogue-emotion-${sceneIdx}`
                : '';
            const onChange = dialogueIdx === -1
                ? ''
                : `onchange="updateEmotion(${sceneIdx}, ${dialogueIdx}, this.value)"`;
            // AI 감정값이 목록에 없으면 자동 추가
            let options = [...EMOTION_OPTIONS];
            const cur = (currentEmotion || '일반').trim();
            if (cur && !options.includes(cur)) {
                options.unshift(cur);
            }
            const opts = options.map(e => {
                const sel = (e === cur) ? ' selected' : '';
                return `<option value="${e}"${sel}>${e}</option>`;
            }).join('');
            return `<select ${id ? 'id="'+id+'"' : ''} ${onChange}
                style="font-size:0.7rem; color:var(--text-muted); background:transparent; border:1px solid var(--border); border-radius:6px; padding:2px 3px; cursor:pointer; flex-shrink:0; max-width:72px;"
                title="감정">${opts}</select>`;
        }

        // 씬별 등장인물 토글 칩 HTML 생성
        function renderCharToggleChips(sceneIdx, sceneChars) {
            const allChars = storyData.characters ? storyData.characters.map(c => c.name || c) : [];
            const activeSet = new Set(sceneChars);
            return allChars.map(c => {
                const isActive = activeSet.has(c);
                const safeC = c.replace(/'/g, "&#39;");
                if (isActive) {
                    return `<span onclick="toggleCharInScene(${sceneIdx}, '${safeC}')" 
                        style="display:inline-flex; align-items:center; gap:2px; background:rgba(99,102,241,0.2); color:var(--primary); padding:3px 10px; border-radius:14px; font-size:0.72rem; font-weight:700; cursor:pointer; border:1.5px solid var(--primary); user-select:none; transition:all 0.15s;" 
                        title="클릭하면 이 씬에서 제외">✓ ${c}</span>`;
                } else {
                    return `<span onclick="toggleCharInScene(${sceneIdx}, '${safeC}')" 
                        style="display:inline-flex; align-items:center; gap:2px; background:transparent; color:var(--text-muted); padding:3px 10px; border-radius:14px; font-size:0.72rem; font-weight:500; cursor:pointer; border:1.5px dashed var(--border); user-select:none; opacity:0.6; transition:all 0.15s;" 
                        title="클릭하면 이 씬에 추가">${c}</span>`;
                }
            }).join('');
        }

        // ============================================
        // 시리즈 분할 설정 로직
        // ============================================
        let seriesConfig = { total: 1, scenesPerSeries: [] };

        function showSeriesPanel() {
            const panel = document.getElementById('series-split-panel');
            if (!panel || !storyData || !storyData.scenes) return;
            const totalScenes = storyData.scenes.length;
            document.getElementById('series-total-scenes-info').textContent = '전체 ' + totalScenes + '장';
            panel.style.display = 'block';
        }

        function onSeriesCountChange(val) {
            const count = parseInt(val) || 1;
            if (count < 1) return;
            const totalScenes = storyData.scenes.length;
            seriesConfig.total = count;

            const configArea = document.getElementById('series-episodes-config');
            if (count <= 1) {
                configArea.style.display = 'none';
                seriesConfig.scenesPerSeries = [totalScenes];
                updateSeriesValidation();
                renderScenes(storyData.scenes);
                return;
            }

            // 균등 분배 기본값
            const base = Math.floor(totalScenes / count);
            const remainder = totalScenes % count;
            seriesConfig.scenesPerSeries = [];
            for (let i = 0; i < count; i++) {
                seriesConfig.scenesPerSeries.push(base + (i < remainder ? 1 : 0));
            }
            renderSeriesEpisodesConfig();
        }

        function renderSeriesEpisodesConfig() {
            const configArea = document.getElementById('series-episodes-config');
            const totalScenes = storyData.scenes.length;
            configArea.style.display = 'block';

            let offset = 0;
            let html = '';
            for (let i = 0; i < seriesConfig.total; i++) {
                const sc = seriesConfig.scenesPerSeries[i] || 0;
                const startScene = offset;
                const endScene = offset + sc - 1;
                const rangeText = sc > 0 ? ('씬 ' + startScene + ' ~ ' + endScene) : '-';
                html += '<div style="display:flex; align-items:center; gap:0.5rem; margin-bottom:0.4rem;">'
                    + '<span style="font-size:0.82rem; font-weight:600; min-width:65px;">시리즈 ' + (i+1) + '</span>'
                    + '<input type="number" value="' + sc + '" min="1" max="' + totalScenes + '"'
                    + ' onchange="onEpisodeSceneCountChange(' + i + ', this.value)"'
                    + ' style="width:55px; text-align:center; border:1px solid var(--border); border-radius:6px; padding:3px;">'
                    + '<span style="font-size:0.75rem; color:var(--text-muted);">장</span>'
                    + '<span style="font-size:0.72rem; color:var(--primary); margin-left:4px;">' + rangeText + '</span>'
                    + '</div>';
                offset += sc;
            }
            // 총합 표시
            const sum = seriesConfig.scenesPerSeries.reduce((a,b) => a+b, 0);
            const match = sum === totalScenes;
            html += '<div style="margin-top:0.5rem; font-size:0.8rem; font-weight:600; color:' + (match ? 'var(--success)' : 'var(--danger)') + ';">'
                + '총합: ' + sum + '장 / 전체 ' + totalScenes + '장 ' + (match ? '✓ 일치' : '✗ 불일치') + '</div>';

            configArea.innerHTML = html;
            updateSeriesValidation();
            renderScenes(storyData.scenes);
        }

        function onEpisodeSceneCountChange(episodeIdx, val) {
            seriesConfig.scenesPerSeries[episodeIdx] = parseInt(val) || 0;
            renderSeriesEpisodesConfig();
        }

        function updateSeriesValidation() {
            const msgEl = document.getElementById('series-validation-msg');
            if (!msgEl) return;
            const totalScenes = storyData.scenes.length;
            const sum = seriesConfig.scenesPerSeries.reduce((a,b) => a+b, 0);

            if (seriesConfig.total <= 1) {
                msgEl.style.display = 'none';
                return;
            }

            if (sum !== totalScenes) {
                msgEl.style.display = 'block';
                msgEl.style.background = 'rgba(239,68,68,0.1)';
                msgEl.style.color = 'var(--danger)';
                msgEl.textContent = '편별 씬 수 합계(' + sum + ')가 전체(' + totalScenes + ')와 맞지 않습니다. 조정해주세요.';
            } else {
                msgEl.style.display = 'block';
                msgEl.style.background = 'rgba(34,197,94,0.1)';
                msgEl.style.color = 'var(--success)';
                msgEl.textContent = '✓ 시리즈 ' + seriesConfig.total + '편 분할 완료 (편당 ' + seriesConfig.scenesPerSeries.join(', ') + '장)';
                // 백엔드에 저장
                saveSeriesConfigToServer();
            }
        }

        async function saveSeriesConfigToServer() {
            if (!sessionId) return;
            try {
                await fetch('/api/workflow/session/' + sessionId + '/series-config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        session_id: sessionId,
                        total_series: seriesConfig.total,
                        scenes_per_series: seriesConfig.scenesPerSeries
                    })
                });
            } catch(e) { console.error('시리즈 설정 저장 실패:', e); }
        }

        function getSeriesForScene(sceneIdx) {
            if (seriesConfig.total <= 1) return -1;
            let offset = 0;
            for (let i = 0; i < seriesConfig.scenesPerSeries.length; i++) {
                if (sceneIdx < offset + seriesConfig.scenesPerSeries[i]) return i;
                offset += seriesConfig.scenesPerSeries[i];
            }
            return -1;
        }

        // ============================================

        function renderScenes(scenes) {
            const container = document.getElementById('scenes-container');
            let prevSeriesIdx = -1;
            container.innerHTML = scenes.map((s, idx) => {
                const densityWarnings = validateSceneRules(s);
                const isCover = s.scene_number === 0;
                const curSeriesIdx = getSeriesForScene(idx);
                let seriesHeader = '';
                if (seriesConfig.total > 1 && curSeriesIdx >= 0 && curSeriesIdx !== prevSeriesIdx) {
                    const epNum = curSeriesIdx + 1;
                    const sc = seriesConfig.scenesPerSeries[curSeriesIdx] || 0;
                    seriesHeader = '<div style="background:var(--primary); color:#fff; padding:6px 14px; border-radius:8px; margin-bottom:0.5rem; font-size:0.85rem; font-weight:700;">📚 시리즈 ' + epNum + ' (' + sc + '장)</div>';
                }
                prevSeriesIdx = curSeriesIdx;

                // 이미지 상태 복원 (이미 생성된 이미지가 있으면 표시)
                const existingImg = (window._sceneImages && window._sceneImages[idx]) || null;
                const imgContent = existingImg
                    ? `<img src="${existingImg}" alt="씬 ${s.scene_number}">`
                    : `<div style="text-align:center; color:var(--text-muted); font-size:0.7rem;">
                        <div style="font-size:1.5rem; margin-bottom:4px;">🖼️</div>대기 중</div>`;
                const imgStatus = existingImg ? '<span style="color:var(--success);">✅ 완료</span>' : '';

                const descLen = (s.scene_description || '').length;
                const narLen = (s.narration || '').length;

                return seriesHeader + `
                <div class="scene-card ${isCover ? 'cover-scene' : ''} ${densityWarnings.length > 0 ? 'warn-scene' : ''}" id="scene-card-${idx}">
                    <!-- 왼쪽: 텍스트 편집 영역 -->
                    <div class="scene-card-left">
                        <!-- 씬 헤더 -->
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <span style="font-weight:700; font-size:0.85rem;">
                                ${isCover 
                                    ? '<span style="background:var(--primary); color:#fff; padding:2px 8px; border-radius:10px; font-size:0.72rem; margin-right:4px;">📌 표지</span> 썸네일' 
                                    : '씬 ' + s.scene_number}
                            </span>
                            <div style="display:flex; gap:4px;">
                                <button onclick="regenerateScene(${idx})" 
                                    style="background:none; border:1px solid var(--primary); color:var(--primary); cursor:pointer; padding:2px 8px; border-radius:6px; font-size:0.68rem; font-weight:600;" title="이 씬만 다시 생성">씬 재생성</button>
                                <button onclick="deleteScene(${idx})" 
                                    style="background:none; border:1px solid var(--danger); color:var(--danger); cursor:pointer; padding:2px 8px; border-radius:6px; font-size:0.68rem; font-weight:600;" title="씬 삭제">삭제</button>
                            </div>
                        </div>

                        <!-- 씬 설명 + 글자수 카운터 -->
                        <div>
                            <div style="display:flex; justify-content:space-between; align-items:center;">
                                <span style="font-size:0.65rem; color:var(--text-muted);">🎬 씬 설명</span>
                                <span class="char-counter ${descLen > 150 ? 'over' : ''}">${descLen}/150</span>
                            </div>
                            <textarea onchange="updateSceneDesc(${idx}, this.value)" oninput="this.previousElementSibling.querySelector('.char-counter').textContent=this.value.length+'/150'; if(this.value.length>150) this.previousElementSibling.querySelector('.char-counter').classList.add('over'); else this.previousElementSibling.querySelector('.char-counter').classList.remove('over');"
                                style="width:100%; border:1px solid var(--border); border-radius:6px; padding:4px 7px; font-size:0.8rem; background:var(--bg-card); resize:vertical; min-height:32px; font-family:inherit; box-sizing:border-box;"
                                rows="2">${(s.scene_description||'').replace(/</g,'&lt;')}</textarea>
                        </div>

                        <!-- 대사 목록 -->
                        ${s.dialogues.map((d, dIdx) => {
                            const dLen = (d.text || '').length;
                            return `
                            <div style="background:var(--bg-input); padding:0.3rem 0.4rem; border-radius:6px; font-size:0.8rem; display:flex; align-items:flex-start; gap:3px;">
                                <div style="padding-top:4px;">${renderSpeakerSelect(idx, dIdx, d.character)}</div>
                                <textarea onchange="updateDialogueText(${idx}, ${dIdx}, this.value)"
                                    style="flex:1; border:1px solid var(--border); border-radius:6px; padding:4px 6px; font-size:0.8rem; background:var(--bg-card); min-width:0; resize:vertical; min-height:36px; font-family:inherit; line-height:1.4; box-sizing:border-box;"
                                    rows="2" placeholder="대사 입력">${(d.text||'').replace(/</g,'&lt;')}</textarea>
                                <div style="display:flex; flex-direction:column; align-items:center; gap:2px; padding-top:4px;">
                                    <span class="char-counter ${dLen > 50 ? 'over' : ''}" style="min-width:30px;">${dLen}/50</span>
                                    ${renderEmotionSelect(idx, dIdx, d.emotion)}
                                    <button onclick="deleteDialogue(${idx}, ${dIdx})" 
                                        style="background:none; border:none; color:var(--danger); cursor:pointer; font-size:0.75rem; padding:0 3px; line-height:1; flex-shrink:0;" title="대사 삭제">삭제</button>
                                </div>
                            </div>`;
                        }).join('')}

                        <!-- 대사 추가 (인라인) -->
                        <div style="background:rgba(99,102,241,0.05); border:1.5px dashed var(--primary); border-radius:6px; padding:0.3rem 0.4rem; display:flex; align-items:flex-start; gap:3px;">
                            <div style="padding-top:4px;">${renderSpeakerSelect(idx, -1, '')}</div>
                            <textarea id="new-dialogue-text-${idx}" placeholder="새 대사 입력 후 Enter"
                                onkeydown="if(event.key==='Enter' && !event.shiftKey){event.preventDefault(); addDialogueInline(${idx});}"
                                style="flex:1; border:1px solid var(--border); border-radius:6px; padding:4px 6px; font-size:0.8rem; background:var(--bg-card); min-width:0; resize:vertical; min-height:36px; font-family:inherit; line-height:1.4; box-sizing:border-box;"
                                rows="2"></textarea>
                            <div style="display:flex; flex-direction:column; align-items:center; gap:2px; padding-top:4px;">
                                ${renderEmotionSelect(idx, -1, '일반')}
                                <button onclick="addDialogueInline(${idx})"
                                    style="background:var(--primary); color:#fff; border:none; cursor:pointer; font-size:0.68rem; padding:3px 8px; border-radius:6px; font-weight:600; flex-shrink:0;">추가</button>
                            </div>
                        </div>

                        <!-- 나레이션 + 글자수 카운터 -->
                        <div>
                            <div style="display:flex; justify-content:space-between; align-items:center;">
                                <span style="font-size:0.65rem; color:var(--text-muted);">💬 나레이션</span>
                                <span class="char-counter ${narLen > 60 ? 'over' : ''}">${narLen}/60</span>
                            </div>
                            <input type="text" value="${(s.narration||'').replace(/"/g,'&quot;')}"
                                onchange="updateNarration(${idx}, this.value)"
                                style="width:100%; border:1px solid var(--border); border-radius:6px; padding:3px 7px; font-size:0.8rem; background:var(--bg-card); font-style:italic; box-sizing:border-box;"
                                placeholder="나레이션 입력 (선택사항)">
                        </div>
                        
                        ${densityWarnings.map(w => `<div class="rule-warning" style="font-size:0.72rem;">⚠️ ${w}</div>`).join('')}
                    </div>

                    <!-- 오른쪽: 이미지 프리뷰 -->
                    <div class="scene-card-right">
                        <div class="scene-img-area" id="scene-img-area-${idx}">
                            <div id="scene-placeholder-${idx}">${imgContent}</div>
                        </div>
                        <div class="scene-img-actions">
                            <button onclick="regenerateOneImage(${idx}, this)" title="이미지 생성">이미지 생성</button>
                            <button onclick="regenerateOneImage(${idx}, this)" title="재생성">재생성</button>
                        </div>
                        <div class="scene-img-actions" style="margin-top:2px;">
                            <button onclick="undoImage(${idx})" id="undo-btn-${idx}"
                                style="display:none; background:none; border:1px solid var(--warning); color:var(--warning); font-size:0.65rem;"
                                title="이전 이미지로 복원">↩ 되돌리기</button>
                        </div>
                        <div class="scene-img-status" id="scene-status-${idx}">${imgStatus}</div>
                    </div>
                </div>
            `}).join('');
        }

        // 씬 설명 인라인 수정
        function updateSceneDesc(idx, value) {
            storyData.scenes[idx].scene_description = value.trim();
        }

        // 나레이션 인라인 수정
        function updateNarration(idx, value) {
            storyData.scenes[idx].narration = value.trim();
        }

        // ── 독백 모드 UI 핸들러 ──
        function onMonologueModeChange() {
            const check = document.getElementById('monologue-mode-check');
            const select = document.getElementById('monologue-char-select');
            const hint = document.getElementById('monologue-hint');
            if (check.checked) {
                updateMonologueCharList();
                select.style.display = 'block';
                hint.style.display = 'none';
            } else {
                select.style.display = 'none';
                hint.style.display = 'inline';
            }
        }

        function updateMonologueCharList() {
            const input = document.getElementById('character-names-input');
            const select = document.getElementById('monologue-char-select');
            if (!input || !select) return;
            const names = input.value.split(',').map(n => n.trim()).filter(n => n);
            select.innerHTML = '<option value="">캐릭터 선택...</option>' +
                names.map(n => `<option value="${n}">${n}</option>`).join('');
            // 이름이 1개면 자동 선택
            if (names.length === 1) {
                select.value = names[0];
            }
        }

        // 캐릭터 이름 입력 변경 시 독백 모드 자동 감지
        document.addEventListener('DOMContentLoaded', function() {
            const charInput = document.getElementById('character-names-input');
            if (charInput) {
                charInput.addEventListener('input', function() {
                    const names = this.value.split(',').map(n => n.trim()).filter(n => n);
                    const check = document.getElementById('monologue-mode-check');
                    if (names.length === 1 && !check.checked) {
                        check.checked = true;
                        onMonologueModeChange();
                        showToast('캐릭터 1명 감지 — 독백 모드가 자동 활성화됩니다', 'info');
                    } else if (names.length > 1 && check.checked) {
                        // 여러 명이면 자동 해제하지 않음 (사용자가 의도적으로 켰을 수 있음)
                        updateMonologueCharList();
                    }
                });
            }
        });

        // ★ 프론트엔드 편집 내용을 백엔드 세션에 일괄 동기화
        async function syncScenesToBackend() {
            if (!sessionId || !storyData || !storyData.scenes) return false;
            try {
                const scenesPayload = storyData.scenes.map(s => ({
                    scene_number: s.scene_number,
                    scene_description: s.scene_description || '',
                    image_prompt: s.image_prompt || null,
                    dialogues: (s.dialogues || []).map(d => ({
                        character: d.character || '',
                        text: d.text || '',
                        emotion: d.emotion || null
                    })),
                    narration: s.narration || ''
                }));
                const res = await fetch('/api/workflow/update-scenes-bulk', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ session_id: sessionId, scenes: scenesPayload })
                });
                if (!res.ok) {
                    const errText = await res.text();
                    console.error('씬 동기화 실패:', errText);
                    return false;
                }
                const data = await res.json();
                console.log(`씬 동기화 완료: ${data.updated_count}개 씬`);
                return true;
            } catch (e) {
                console.error('씬 동기화 오류:', e);
                return false;
            }
        }

        // 말하는 사람 변경 (드롭다운)
        function changeSpeaker(sceneIdx, dialogueIdx, newName) {
            const old = storyData.scenes[sceneIdx].dialogues[dialogueIdx].character;
            storyData.scenes[sceneIdx].dialogues[dialogueIdx].character = newName;
            showToast(`${old} → ${newName}`, 'success');
            // 토글 칩 상태도 갱신
            renderScenes(storyData.scenes);
        }

        // 대사 텍스트 인라인 수정
        function updateDialogueText(sceneIdx, dialogueIdx, newText) {
            if (newText && newText.trim()) {
                storyData.scenes[sceneIdx].dialogues[dialogueIdx].text = newText.trim();
            }
        }

        // 감정 인라인 수정
        function updateEmotion(sceneIdx, dialogueIdx, newEmotion) {
            storyData.scenes[sceneIdx].dialogues[dialogueIdx].emotion = newEmotion;
        }

        // 대사 인라인 추가 (팝업 없이)
        function addDialogueInline(sceneIdx) {
            const charEl = document.getElementById(`new-dialogue-char-${sceneIdx}`);
            const textEl = document.getElementById(`new-dialogue-text-${sceneIdx}`);
            const emotionEl = document.getElementById(`new-dialogue-emotion-${sceneIdx}`);
            if (!charEl || !textEl) return;

            const charName = charEl.value;
            const text = textEl.value.trim();
            const emotion = emotionEl ? emotionEl.value : '일반';

            if (!text) {
                showToast('대사를 입력해주세요.', 'error');
                textEl.focus();
                return;
            }

            storyData.scenes[sceneIdx].dialogues.push({
                character: charName,
                text: text,
                emotion: emotion
            });
            renderScenes(storyData.scenes);
            showToast(`${charName}의 대사 추가됨`, 'success');
        }

        // 대사 삭제
        function deleteDialogue(sceneIdx, dialogueIdx) {
            const d = storyData.scenes[sceneIdx].dialogues[dialogueIdx];
            if (!confirm(`"${d.character}: ${d.text.substring(0, 30)}..." 대사를 삭제하시겠습니까?`)) return;
            storyData.scenes[sceneIdx].dialogues.splice(dialogueIdx, 1);
            renderScenes(storyData.scenes);
            showToast('대사가 삭제되었습니다.', 'success');
        }

        // 씬 등장인물 토글 (원클릭 ON/OFF)
        function toggleCharInScene(sceneIdx, charName) {
            const scene = storyData.scenes[sceneIdx];
            const sceneChars = [...new Set(scene.dialogues.map(d => d.character))];
            const isActive = sceneChars.includes(charName);

            if (isActive) {
                // --- OFF: 씬에서 제거 ---
                const dialogueCount = scene.dialogues.filter(d => d.character === charName).length;
                if (dialogueCount > 0 && !confirm(`"${charName}"의 대사 ${dialogueCount}개가 삭제됩니다. 제거할까요?`)) return;

                scene.dialogues = scene.dialogues.filter(d => d.character !== charName);
                if (scene.scene_description) {
                    scene.scene_description = scene.scene_description.replace(new RegExp(charName, 'g'), '').replace(/\s{2,}/g, ' ').trim();
                }
                if (scene.narration) {
                    scene.narration = scene.narration.replace(new RegExp(charName, 'g'), '').replace(/\s{2,}/g, ' ').trim();
                }
                renderScenes(storyData.scenes);
                showToast(`"${charName}" OFF — 씬 ${scene.scene_number}에서 제외`, 'info');
            } else {
                // --- ON: 씬에 추가 (빈 대사 1개 자동 생성) ---
                scene.dialogues.push({
                    character: charName,
                    text: '(대사를 입력하세요)',
                    emotion: '일반'
                });
                renderScenes(storyData.scenes);
                showToast(`"${charName}" ON — 씬 ${scene.scene_number}에 추가됨 (대사를 클릭하여 수정)`, 'success');
            }
        }

        // 씬 재생성 함수
        async function regenerateScene(idx) {
            if (!confirm(`씬 ${idx + 1}을 AI로 다시 생성하시겠습니까?\n기존 대사와 설명이 새로운 내용으로 교체됩니다.`)) return;
            if (!sessionId) { showToast('세션이 없습니다.', 'error'); return; }

            // 로딩 표시
            const sceneCard = document.querySelector(`#scene-card-${idx}`) || document.querySelector(`[data-scene-idx="${idx}"]`);
            const origHtml = sceneCard ? sceneCard.innerHTML : null;
            if (sceneCard) {
                const overlay = document.createElement('div');
                overlay.id = `regen-overlay-${idx}`;
                overlay.style.cssText = 'position:absolute;inset:0;background:rgba(0,0,0,0.5);display:flex;align-items:center;justify-content:center;z-index:10;border-radius:8px;';
                overlay.innerHTML = '<div style="text-align:center;color:#fff;"><div class="spinner" style="width:24px;height:24px;border-width:3px;margin:0 auto 8px;"></div><div style="font-size:0.8rem;">AI 재생성 중...</div></div>';
                sceneCard.style.position = 'relative';
                sceneCard.appendChild(overlay);
            }

            try {
                const res = await fetch('/api/workflow/regenerate-scene', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ session_id: sessionId, scene_index: idx })
                });
                const data = await res.json();
                if (data.scene) {
                    // 스토리 데이터 업데이트
                    storyData.scenes[idx] = data.scene;
                    renderScenes(storyData.scenes);
                    showToast(`씬 ${idx + 1} 재생성 완료`, 'success');
                } else {
                    throw new Error(data.detail || '재생성 실패');
                }
            } catch (e) {
                showToast('씬 재생성 오류: ' + e.message, 'error');
            } finally {
                const overlay = document.getElementById(`regen-overlay-${idx}`);
                if (overlay) overlay.remove();
            }
        }

        // 씬 삭제 함수
        function deleteScene(idx) {
            if (!confirm(`씬 ${idx + 1}을 삭제하시겠습니까?`)) return;

            // 씬 삭제
            storyData.scenes.splice(idx, 1);

            // 씬 번호 재정렬 (표지 scene_number=0은 유지)
            const hasCover = storyData.scenes.length > 0 && storyData.scenes[0].scene_number === 0;
            storyData.scenes.forEach((scene, index) => {
                if (index === 0 && hasCover) return; // 표지(0번)는 번호 유지
                scene.scene_number = hasCover ? index : index + 1;
            });

            renderScenes(storyData.scenes);
        }

        // 초기화 시 자동 복원 및 기본 모델 설정
        // API 상태 바 업데이트
        async function refreshApiStatusBar() {
            try {
                const res = await fetch('/api/sns/system/status');
                if (!res.ok) return;
                const data = await res.json();
                const statusMap = {
                    ok: { icon: '🟢', label: '연결됨' },
                    warning: { icon: '🟡', label: '경고' },
                    error: { icon: '🔴', label: '오류' },
                    expired: { icon: '🔴', label: '만료' },
                    no_key: { icon: '⚪', label: '미설정' },
                };
                ['gemini', 'instagram', 'cloudinary'].forEach(svc => {
                    const el = document.getElementById(`api-st-${svc}`);
                    if (!el) return;
                    const st = statusMap[data[svc]] || statusMap.no_key;
                    const name = svc.charAt(0).toUpperCase() + svc.slice(1);
                    el.innerText = `${st.icon} ${name}`;
                    el.title = `${name}: ${st.label}`;
                });
            } catch(e) { /* 상태 바 업데이트 실패 무시 */ }
        }

        window.addEventListener('DOMContentLoaded', async () => {
            // 0. API 상태 바 초기화
            refreshApiStatusBar();
            // 5분마다 자동 갱신
            setInterval(refreshApiStatusBar, 5 * 60 * 1000);

            // 1. 기본 모델 설정
            const modelSelect = document.getElementById('ai-model-select');
            if (modelSelect) {
                const selectedOption = modelSelect.querySelector('option[selected]');
                if (selectedOption) {
                    modelSelect.value = selectedOption.value;
                } else {
                    modelSelect.value = "gemini-3-flash-preview";
                }
            }

            // 2. 자동 세션 복원 (개발 효율성)
            const savedSessionId = localStorage.getItem('lastSessionId');
            if (savedSessionId) {
                console.log('Found saved session:', savedSessionId);
                try {
                    // 세션 유효성 확인 및 데이터 로드
                    const res = await fetch(`/api/workflow/session/${savedSessionId}`);
                    if (res.ok) {
                        const session = await res.json();
                        sessionId = session.session_id;

                        // 데이터 복원
                        if (session.story) {
                            storyData = session.story;
                            characters = storyData.characters || [];
                            collectedData = session.collected_data || [];

                            // UI 렌더링
                            renderCharacters();
                            renderScenes(storyData.scenes || []);

                            // 3단계(스토리 편집)로 이동
                            // 만약 이미지가 생성된 상태라면 4단계나 5단계로 갈 수도 있겠지만, 
                            // 일단 사용자가 요청한 "3번 탭부터 시작"을 위해 데이터가 있으면 3단계로 이동

                            document.getElementById('loading-story').style.display = 'none';
                            document.getElementById('story-review-area').style.display = 'block';
                            document.getElementById('story-actions').style.display = 'flex';
                            const saveArea = document.getElementById('story-save-area');
                            if (saveArea) saveArea.style.display = 'flex';

                            goToStep(3);

                            // 만약 이미지 생성 단계까지 갔던 세션이라면?
                            if (session.images && session.images.length > 0) {
                                // 선택적으로 5단계 등으로 이동 가능. 일단은 3단계 유지하거나 알림.
                                console.log('This session has generated images.');
                            }

                            console.log('Session restored functionality enabled.');
                        } else if (session.collected_data && session.collected_data.length > 0) {
                            // 데이터수집은 했지만 스토리는 없는 경우 -> 2단계
                            collectedData = session.collected_data;
                            renderDataItems();
                            goToStep(2);
                        }
                    } else {
                        console.log('Saved session is invalid or expired.');
                        localStorage.removeItem('lastSessionId');
                    }
                } catch (e) {
                    console.error('Auto-restore failed:', e);
                }
            }
        });

        function validateSceneRules(scene) {
            const warnings = [];
            scene.dialogues.forEach(d => {
                if (d.text.length > 50) warnings.push(`${d.character} 대사가 너무 깁니다 (${d.text.length}자 > 50자)`);
            });
            if (scene.dialogues.length > 3) warnings.push(`말풍선이 너무 많습니다 (${scene.dialogues.length}개 > 3개)`);
            if (scene.narration && scene.narration.length > 60) warnings.push(`나레이션이 너무 깁니다 (${scene.narration.length}자 > 60자)`);
            return warnings;
        }

        // ── 스토리 수동 저장 ──
        async function saveStoryManual() {
            const nameEl = document.getElementById('story-save-name');
            const saveName = (nameEl ? nameEl.value.trim() : '') || `스토리_${new Date().toLocaleString('ko-KR')}`;
            if (!storyData) {
                showToast('저장할 스토리가 없습니다. 먼저 스토리를 생성하세요.', 'error');
                return;
            }
            try {
                // 세션이 유효하면 session_id로, 만료되었으면 storyData 직접 전달
                const payload = { save_name: saveName };
                if (sessionId) {
                    payload.session_id = sessionId;
                }
                // 세션 만료 대비: storyData도 항상 함께 전달
                payload.story_data = storyData;
                payload.keyword = storyData.title || '';

                const res = await fetch('/api/workflow/story/save', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await res.json();
                if (res.ok && data.success) {
                    showToast(`"${saveName}" 저장 완료`, 'success');
                    if (nameEl) nameEl.value = '';
                    loadSavedStories();
                } else {
                    showToast('저장 실패: ' + (data.detail || data.message || '알 수 없는 오류'), 'error');
                }
            } catch (e) {
                showToast('저장 오류: ' + e.message, 'error');
            }
        }

        // ── 저장 목록 토글 ──
        function toggleSavedStories() {
            const listEl = document.getElementById('saved-stories-list');
            if (listEl.style.display === 'none') {
                listEl.style.display = 'block';
                loadSavedStories();
            } else {
                listEl.style.display = 'none';
            }
        }

        // ── 저장 목록 로드 ──
        async function loadSavedStories() {
            const listEl = document.getElementById('saved-stories-list');
            try {
                const res = await fetch('/api/workflow/history/stories');
                const stories = await res.json();
                if (!stories || stories.length === 0) {
                    listEl.innerHTML = '<div style="text-align:center; padding:1rem; color:var(--text-muted); font-size:0.8rem;">저장된 스토리가 없습니다.</div>';
                    return;
                }
                listEl.innerHTML = stories.map(s => {
                    const displayName = s.save_name || s.keyword || s.title || 'Untitled';
                    const dateStr = s.timestamp ? new Date(s.timestamp).toLocaleString('ko-KR') : '';
                    return `
                    <div style="display:flex; align-items:center; gap:6px; padding:6px 8px; border-bottom:1px solid var(--border); font-size:0.78rem;">
                        <div style="flex:1; min-width:0;">
                            <div style="font-weight:600; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${displayName}</div>
                            <div style="color:var(--text-muted); font-size:0.68rem;">${dateStr} · ${s.scene_count || '?'}씬</div>
                        </div>
                        <button onclick="loadSavedStory('${s.filename}')" class="btn btn-primary" style="font-size:0.68rem; padding:2px 8px; flex-shrink:0;">불러오기</button>
                        <button onclick="saveAsNewName('${s.filename.replace(/'/g, "\\'")}', '${displayName.replace(/'/g, "\\'")}')" class="btn btn-secondary" style="font-size:0.62rem; padding:2px 6px; flex-shrink:0;" title="현재 스토리를 다른 이름으로 저장">다른이름저장</button>
                        <button onclick="deleteSavedStory('${s.filename}')" style="background:none; border:none; color:var(--danger); cursor:pointer; font-size:0.9rem; padding:0 2px; flex-shrink:0;" title="삭제">×</button>
                    </div>`;
                }).join('');
            } catch (e) {
                listEl.innerHTML = '<div style="color:var(--danger); padding:0.5rem; font-size:0.8rem;">목록 로드 실패</div>';
            }
        }

        // ── 저장된 스토리 불러오기 ──
        async function loadSavedStory(filename) {
            if (!confirm('현재 스토리를 저장된 스토리로 교체합니다. 계속할까요?')) return;
            try {
                const res = await fetch('/api/workflow/history/load', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ session_id: sessionId || null, filename })
                });
                if (!res.ok) {
                    const errData = await res.json().catch(() => ({}));
                    showToast('불러오기 실패: ' + (errData.detail || `서버 오류 ${res.status}`), 'error');
                    return;
                }
                const data = await res.json();
                if (data.success) {
                    // 새 세션 ID 반영 (서버에서 세션 생성/복원)
                    if (data.session_id) sessionId = data.session_id;
                    storyData = data.story;
                    if (data.collected_data) collectedData = data.collected_data;
                    
                    // 이미지 데이터 복원 (저장된 이미지가 있는 경우)
                    if (data.images && data.images.length > 0) {
                        window._sceneImages = {};
                        data.images.forEach((img, idx) => {
                            if (img.local_path && img.status !== 'missing') {
                                const url = getImageUrl(img.local_path);
                                // scene_number 기반으로 인덱스 매핑
                                // scene_number가 0이면 표지(idx=0), 아니면 씬 순서대로
                                const sceneIdx = data.images.findIndex(i => i === img);
                                window._sceneImages[sceneIdx] = url;
                            }
                        });
                    }
                    
                    renderCharacters();
                    renderScenes(storyData.scenes);
                    // 스토리 UI 표시
                    document.getElementById('story-review-area').style.display = 'block';
                    document.getElementById('story-actions').style.display = 'flex';
                    const saveArea = document.getElementById('story-save-area');
                    if (saveArea) saveArea.style.display = 'flex';
                    const genBtn = document.getElementById('btn-generate-story');
                    if (genBtn) genBtn.style.display = 'none';
                    
                    // 이미지 생성 컨트롤 바 표시 (씬이 있을 때)
                    if (storyData.scenes && storyData.scenes.length > 0) {
                        const genBar = document.getElementById('gen-control-bar');
                        if (genBar) genBar.style.display = 'block';
                    }
                    
                    // 편집 버튼 활성화 (이미지가 있을 때)
                    const editBtn = document.getElementById('btn-to-edit');
                    if (editBtn) {
                        const hasImages = window._sceneImages && Object.keys(window._sceneImages).length > 0;
                        editBtn.disabled = !hasImages;
                        editBtn.title = hasImages ? '' : '먼저 이미지를 생성하세요';
                    }
                    
                    const imgCount = window._sceneImages ? Object.keys(window._sceneImages).length : 0;
                    showToast(`스토리 불러오기 완료${imgCount > 0 ? ` (이미지 ${imgCount}개 복원)` : ''}`, 'success');
                } else {
                    showToast('불러오기 실패: ' + (data.detail || ''), 'error');
                }
            } catch (e) {
                showToast('불러오기 오류: ' + e.message, 'error');
            }
        }

        // ── 다른 이름으로 저장 ──
        async function saveAsNewName(originalFilename, originalName) {
            const newName = prompt('새 저장 이름을 입력하세요:', originalName + '_수정');
            if (!newName || !newName.trim()) return;
            if (!storyData) {
                showToast('현재 스토리가 없습니다. 먼저 불러오기 후 저장하세요.', 'error');
                return;
            }
            try {
                // 세션 만료 대비: storyData 직접 전달
                const payload = { save_name: newName.trim() };
                if (sessionId) payload.session_id = sessionId;
                payload.story_data = storyData;
                payload.keyword = storyData.title || '';

                const res = await fetch('/api/workflow/story/save', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await res.json();
                if (res.ok && data.success) {
                    showToast(`"${newName.trim()}" 저장 완료`, 'success');
                    loadSavedStories();
                } else {
                    showToast('저장 실패: ' + (data.detail || data.message || ''), 'error');
                }
            } catch (e) {
                showToast('저장 오류: ' + e.message, 'error');
            }
        }

        // ── 저장된 스토리 삭제 ──
        async function deleteSavedStory(filename) {
            if (!confirm('이 스토리를 삭제할까요?')) return;
            try {
                await fetch(`/api/workflow/story/delete/${filename}`, { method: 'DELETE' });
                showToast('삭제 완료', 'success');
                loadSavedStories();
            } catch (e) {
                showToast('삭제 오류: ' + e.message, 'error');
            }
        }

        async function approveScenes() {
            // ★ 스토리 편집 내용을 백엔드에 동기화 (step 4 진입 전)
            await syncScenesToBackend();

            goToStep(4);
            const sceneCountEl = document.getElementById('image-scene-count');
            if (sceneCountEl) sceneCountEl.innerText = storyData.scenes.length;
            const estTimeEl = document.getElementById('image-est-time');
            if (estTimeEl) estTimeEl.innerText = Math.ceil(storyData.scenes.length * 0.25);

            // 시리즈 선택 드롭다운 업데이트
            updateSeriesGenSelector();

            // 프리셋 레퍼런스 자동 적용 (3종 이미지를 세션에 복사)
            await applyPresetReferencesToSession();
        }

        function updateSeriesGenSelector() {
            const selector = document.getElementById('series-gen-selector');
            const select = document.getElementById('target-series');
            if (!selector || !select) return;

            if (seriesConfig.total <= 1) {
                selector.style.display = 'none';
                return;
            }

            selector.style.display = 'block';
            select.innerHTML = '<option value="all">전체 시리즈</option>';
            for (let i = 0; i < seriesConfig.total; i++) {
                const sc = seriesConfig.scenesPerSeries[i] || 0;
                select.innerHTML += '<option value="' + (i+1) + '">시리즈 ' + (i+1) + ' (' + sc + '장)</option>';
            }
        }

        function updateEstTime() {
            const sel = document.getElementById('target-series');
            const val = sel ? sel.value : 'all';
            let count = storyData.scenes.length;
            if (val !== 'all') {
                const idx = parseInt(val) - 1;
                count = seriesConfig.scenesPerSeries[idx] || count;
            }
            const estTimeEl = document.getElementById('image-est-time');
            if (estTimeEl) estTimeEl.innerText = Math.ceil(count * 0.25);
        }

        // --- Step 4: 설정 탭 관리 ---
        function switchSettingTab(tab) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.style.display = 'none');

            event.target.classList.add('active');
            document.getElementById(`setting-tab-${tab}`).style.display = 'block';
        }

        // --- Step 5: 이미지 생성 ---
        var genPollInterval = null;  // 폴링 interval
        var genIsStopped = false;    // 중단 플래그
        var genIsPaused = false;     // 일시정지 플래그

        function getImageUrl(localPath) {
            // output/scene_1_xxx.png → /output/scene_1_xxx.png
            if (!localPath) return '';
            if (localPath.startsWith('/')) return localPath;
            if (localPath.startsWith('http')) return localPath;
            return '/' + localPath.replace(/\\/g, '/');
        }

        // 스토리탭 → 편집탭으로 이동 (동기화 후)
        async function goToEditFromStory() {
            await syncScenesToBackend();
            await applyPresetReferencesToSession();
            goToStep(4);
        }

        // 씬 카드 이미지 영역 업데이트 (탭3 통합용)
        function updateSceneImage(idx, state, imgData) {
            const imgArea = document.getElementById(`scene-img-area-${idx}`);
            const placeholder = document.getElementById(`scene-placeholder-${idx}`);
            const statusEl = document.getElementById(`scene-status-${idx}`);
            const card = document.getElementById(`scene-card-${idx}`);
            if (!imgArea) return;

            if (state === 'generating') {
                const startTime = Date.now();
                if (card && !card._genTimer) {
                    card._genStartTime = startTime;
                    card._genTimer = setInterval(() => {
                        const elapsed = Math.floor((Date.now() - card._genStartTime) / 1000);
                        const timerEl = document.getElementById(`scene-timer-${idx}`);
                        if (timerEl) timerEl.innerText = `${elapsed}초`;
                    }, 1000);
                }
                if (placeholder) {
                    placeholder.innerHTML = `
                        <div class="spinner" style="width:20px;height:20px;border-width:2px;margin-bottom:4px;"></div>
                        <div style="font-size:0.65rem;color:var(--primary);font-weight:600;">생성 중</div>
                        <div id="scene-timer-${idx}" style="font-size:0.6rem;color:var(--text-muted);">0초</div>`;
                }
                if (statusEl) statusEl.innerHTML = '<span style="color:var(--primary);">🎨 생성 중...</span>';
                if (card) card.style.borderColor = 'var(--primary)';

            } else if (state === 'done' && imgData) {
                if (card && card._genTimer) { clearInterval(card._genTimer); card._genTimer = null; }
                const elapsed = card && card._genStartTime ? Math.floor((Date.now() - card._genStartTime) / 1000) : 0;
                const url = getImageUrl(imgData.local_path);
                // 이미지 캐시 저장 (renderScenes 재호출 시 복원용)
                if (!window._sceneImages) window._sceneImages = {};
                window._sceneImages[idx] = url;
                imgArea.innerHTML = `<img src="${url}" alt="씬 ${idx}">`;
                if (statusEl) statusEl.innerHTML = `<span style="color:var(--success);">✅ ${elapsed}초</span>`;
                if (card) card.style.borderColor = 'var(--success)';

            } else if (state === 'error') {
                if (card && card._genTimer) { clearInterval(card._genTimer); card._genTimer = null; }
                const errElapsed = card && card._genStartTime ? Math.floor((Date.now() - card._genStartTime) / 1000) : 0;
                if (placeholder) {
                    placeholder.innerHTML = `
                        <div style="text-align:center;">
                            <span style="font-size:1.5rem;">⚠️</span>
                            <div style="font-size:0.65rem;color:var(--danger);margin-top:2px;">실패 (${errElapsed}초)</div>
                        </div>`;
                }
                if (statusEl) statusEl.innerHTML = '<span style="color:var(--danger);">❌ 오류</span>';
                if (card) card.style.borderColor = 'var(--danger)';

            } else if (state === 'stopped') {
                if (card && card._genTimer) { clearInterval(card._genTimer); card._genTimer = null; }
                if (placeholder) {
                    placeholder.innerHTML = `
                        <div style="text-align:center;">
                            <div style="font-size:1.2rem;">⏹️</div>
                            <div style="font-size:0.65rem;color:var(--text-muted);">중단</div>
                        </div>`;
                }
                if (statusEl) statusEl.innerText = '⏹️ 중단';
                if (card) card.style.borderColor = 'var(--border)';
            }
        }

        async function startImageGeneration() {
            // 유효성 검사
            if (!storyData || !storyData.scenes || storyData.scenes.length === 0) {
                showToast('생성할 씬이 없습니다.', 'warning');
                return;
            }
            // 빈 씬 설명 경고
            const emptyScenes = storyData.scenes.filter(s => !(s.scene_description || '').trim());
            if (emptyScenes.length > 0) {
                showToast(`⚠️ ${emptyScenes.length}개 씬에 설명이 비어있습니다. 이미지 품질이 낮을 수 있습니다.`, 'warning');
            }

            genIsStopped = false;
            genIsPaused = false;

            // 스토리 편집 내용 동기화
            const syncOk = await syncScenesToBackend();
            if (!syncOk) {
                if (!confirm('스토리 편집 내용을 서버에 동기화하지 못했습니다.\n원본 스토리로 이미지를 생성할까요?')) {
                    return;
                }
            }

            // 프리셋 레퍼런스 적용
            await applyPresetReferencesToSession();

            const sceneCount = storyData.scenes.length;

            // 컨트롤 바 UI 초기화
            const controlBar = document.getElementById('gen-control-bar');
            const controlBtns = document.getElementById('gen-control-buttons');
            const actionsEl = document.getElementById('image-actions');
            controlBar.style.display = 'block';
            controlBtns.style.display = 'flex';
            actionsEl.style.display = 'none';
            document.getElementById('btn-start-gen').disabled = true;
            document.getElementById('btn-start-gen').innerText = '⏳ 생성 중...';

            // 진행 상태 초기화
            document.getElementById('gen-status-text').innerText = '🎨 이미지 생성 중...';
            document.getElementById('gen-status-count').innerText = `0/${sceneCount}`;
            document.getElementById('gen-progress-bar').style.width = '0%';
            document.getElementById('gen-status-sub').innerText = '첫 번째 씬을 생성하고 있습니다...';

            // 씬 카드 이미지 영역 초기화
            for (let i = 0; i < sceneCount; i++) {
                const placeholder = document.getElementById(`scene-placeholder-${i}`);
                if (placeholder) {
                    placeholder.innerHTML = `<div style="text-align:center; color:var(--text-muted); font-size:0.7rem;">
                        <div style="font-size:1.2rem; margin-bottom:2px;">⏳</div>대기 중</div>`;
                }
                const statusEl = document.getElementById(`scene-status-${i}`);
                if (statusEl) statusEl.innerText = '';
            }

            const model = 'nano-banana-pro';
            const ratio = document.getElementById('gen-aspect-ratio').value;

            try {
                // 첫 번째 씬 "생성 중" 표시
                updateSceneImage(0, 'generating');

                const reqBody = {
                    session_id: sessionId,
                    character_style_id: null,
                    background_style_id: null,
                    trained_character_id: null,
                    sub_style: "",
                    manual_overrides: { character_style_prompt: "", background_style_prompt: "", style_prompt: "", additional_instructions: "" },
                    model: model,
                    aspect_ratio: ratio,
                    use_reference_images: true,
                    scene_chaining: true
                };

                fetch('/api/workflow/generate-images', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(reqBody)
                }).catch(e => {
                    console.error('이미지 생성 백엔드 오류:', e);
                    showToast('이미지 생성 요청 실패: ' + e.message, 'error');
                });

                checkImageProgress(sceneCount);
            } catch (e) {
                showToast('이미지 생성 시작 오류: ' + e.message, 'error');
                document.getElementById('btn-start-gen').disabled = false;
                document.getElementById('btn-start-gen').innerText = '🎨 전체 이미지 생성';
            }
        }

        // 하위 호환 래퍼 (기존 코드에서 호출할 수 있으므로 유지)
        function updateSceneCard(idx, state, imgData) {
            updateSceneImage(idx, state, imgData);
        }

        function checkImageProgress(total) {
            let prevCount = 0;
            let pollCount = 0;
            let consecutiveErrors = 0;  // 연속 실패 카운터

            const statusText = document.getElementById('gen-status-text');
            const statusCount = document.getElementById('gen-status-count');
            const progressBar = document.getElementById('gen-progress-bar');
            const statusSub = document.getElementById('gen-status-sub');
            const actionsEl = document.getElementById('image-actions');
            const controlBtns = document.getElementById('gen-control-buttons');

            genPollInterval = setInterval(async () => {
                if (genIsPaused) return; // 일시정지면 스킵
                if (genIsStopped) {
                    clearInterval(genPollInterval);
                    return;
                }
                pollCount++;
                try {
                    const res = await fetch(`/api/workflow/session/${sessionId}`);
                    if (!res.ok) throw new Error(`서버 응답 오류 (${res.status})`);
                    const session = await res.json();
                    consecutiveErrors = 0;  // 성공 시 리셋

                    const allImages = session.images || [];
                    const doneCount = allImages.length;  // 생성완료 + 에러 합산
                    const generated = allImages.filter(img => img.status === 'generated');
                    const errors = allImages.filter(img => img.status === 'error');
                    const genCount = generated.length;

                    // 새로 완료된 씬 카드 업데이트
                    for (let i = prevCount; i < doneCount; i++) {
                        const imgData = allImages[i];
                        if (imgData.status === 'generated' && imgData.local_path) {
                            updateSceneCard(i, 'done', imgData);
                        } else {
                            updateSceneCard(i, 'error', imgData);
                        }
                    }

                    // 다음 생성 중인 씬 표시
                    if (doneCount < total) {
                        updateSceneCard(doneCount, 'generating');
                    }

                    prevCount = doneCount;

                    // 상단 바 업데이트 (에러 포함한 전체 진행률)
                    const pct = total > 0 ? Math.round((doneCount / total) * 100) : 0;
                    progressBar.style.width = `${pct}%`;
                    statusCount.innerText = `${genCount}/${total}`;

                    if (genCount > 0 && genCount < total) {
                        statusText.innerText = `🎨 ${genCount}/${total} 생성 완료`;
                        statusSub.innerText = `씬 ${doneCount + 1} 생성 중... (씬당 약 15~30초)`;
                    } else if (genCount === 0) {
                        statusText.innerText = '🎨 이미지 생성 중...';
                        statusSub.innerText = pollCount > 3 ? '씬 1 생성 중... (첫 씬은 조금 더 걸립니다)' : '첫 번째 씬을 생성하고 있습니다...';
                    }

                    if (errors.length > 0) {
                        statusSub.innerText += ` (⚠️ ${errors.length}개 오류)`;
                    }

                    // 전체 완료
                    if (doneCount >= total) {
                        clearInterval(genPollInterval);
                        genPollInterval = null;
                        statusText.innerText = `✅ ${genCount}/${total} 이미지 생성 완료!`;
                        statusSub.innerText = errors.length > 0 ? `⚠️ ${errors.length}개 씬에서 오류 발생 — 개별 재생성 가능` : '모든 씬이 정상 생성되었습니다';
                        progressBar.style.width = '100%';
                        controlBtns.style.display = 'none';
                        actionsEl.style.display = 'flex';
                        // 생성 버튼 복원
                        const startBtn = document.getElementById('btn-start-gen');
                        if (startBtn) { startBtn.disabled = false; startBtn.innerText = '🎨 전체 이미지 생성'; }
                        // 이미지 편집 버튼 활성화
                        const editBtn = document.getElementById('btn-to-edit');
                        if (editBtn) {
                            const hasImages = window._sceneImages && Object.keys(window._sceneImages).length > 0;
                            editBtn.disabled = !hasImages;
                            editBtn.title = hasImages ? '' : '먼저 이미지를 생성하세요';
                        }
                    }
                } catch (e) {
                    console.error('진행률 확인 오류:', e);
                    consecutiveErrors++;
                    // 연속 5회 실패 시 경고, 10회 실패 시 폴링 중단
                    if (consecutiveErrors === 5) {
                        statusSub.innerText = '⚠️ 서버 연결이 불안정합니다. 재시도 중...';
                    }
                    if (consecutiveErrors >= 10) {
                        clearInterval(genPollInterval);
                        genPollInterval = null;
                        statusText.innerText = '⚠️ 서버 연결이 끊어졌습니다';
                        statusSub.innerText = '네트워크를 확인하고 페이지를 새로고침하세요. 이미 생성된 이미지는 서버에 보존됩니다.';
                        controlBtns.style.display = 'none';
                        actionsEl.style.display = 'flex';
                        showToast('서버 연결 실패 — 진행률 확인이 중단되었습니다', 'error');
                    }
                }
            }, 2500);
        }

        function pauseGeneration() {
            genIsPaused = !genIsPaused;
            const btn = document.getElementById('btn-pause');
            if (genIsPaused) {
                btn.innerText = '▶️ 계속';
                document.getElementById('gen-status-sub').innerText = '⏸️ 일시정지됨 — "계속" 버튼을 눌러 진행률 확인을 재개하세요';
            } else {
                btn.innerText = '⏸️ 일시정지';
                document.getElementById('gen-status-sub').innerText = '다시 진행률을 확인 중입니다...';
            }
        }

        function stopGeneration() {
            if (!confirm('이미지 생성을 중단하시겠습니까?\n이미 생성된 이미지는 유지됩니다.')) return;
            genIsStopped = true;
            if (genPollInterval) {
                clearInterval(genPollInterval);
                genPollInterval = null;
            }

            // 백엔드에 중단 신호 보내기
            fetch('/api/workflow/stop-generation', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ session_id: sessionId })
            }).catch(e => console.error('중단 요청 오류:', e));

            // 남은 미완성 카드들에 "중단됨" 표시
            const total = storyData.scenes.length;
            for (let i = 0; i < total; i++) {
                const statusEl = document.getElementById(`scene-status-${i}`);
                if (statusEl && statusEl.innerText.includes('대기') || (statusEl && statusEl.innerText.includes('생성 중'))) {
                    updateSceneCard(i, 'stopped');
                }
            }

            document.getElementById('gen-status-text').innerText = '⏹️ 생성이 중단되었습니다';
            document.getElementById('gen-status-sub').innerText = '이미 생성된 이미지는 씬 카드에서 확인할 수 있습니다';
            document.getElementById('gen-control-buttons').style.display = 'none';
            document.getElementById('image-actions').style.display = 'flex';
            const startBtn = document.getElementById('btn-start-gen');
            if (startBtn) { startBtn.disabled = false; startBtn.innerText = '🎨 전체 이미지 생성'; }
        }

        async function regenerateOneImage(sceneIndex, btnElement) {
            const btn = btnElement || document.querySelector(`#scene-card-${sceneIndex} .regen-btn`);
            if (!btn) return;
            const origText = btn.innerText;
            btn.innerText = '⏳ 재생성 중...';
            btn.disabled = true;

            // 카드도 로딩 상태로 전환
            updateSceneCard(sceneIndex, 'generating');

            try {
                const model = 'nano-banana-pro'; // Gemini 3.0 Preview 고정
                const res = await fetch('/api/workflow/regenerate-image', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ session_id: sessionId, scene_index: sceneIndex, model: model })
                });

                if (!res.ok) {
                    const errText = await res.text();
                    throw new Error(`서버 오류 (${res.status}): ${errText}`);
                }

                const data = await res.json();
                if (data.image && data.image.local_path) {
                    updateSceneCard(sceneIndex, 'done', data.image);
                    // 되돌리기 버튼 표시/숨김
                    const undoBtn = document.getElementById(`undo-btn-${sceneIndex}`);
                    if (undoBtn) {
                        const histCount = data.history_count || (data.image.image_history ? data.image.image_history.length : 0);
                        undoBtn.style.display = histCount > 0 ? 'inline-block' : 'none';
                    }
                } else {
                    throw new Error('이미지 경로가 없습니다');
                }
            } catch (e) {
                updateSceneCard(sceneIndex, 'error');
                showToast('재생성 실패: ' + e.message, 'error');
            } finally {
                btn.innerText = origText;
                btn.disabled = false;
            }
        }

        // --- 이미지 되돌리기 ---
        async function undoImage(sceneIndex) {
            const undoBtn = document.getElementById(`undo-btn-${sceneIndex}`);
            if (!undoBtn) return;
            
            const origText = undoBtn.innerText;
            undoBtn.innerText = '↩ 복원 중...';
            undoBtn.disabled = true;
            
            try {
                const res = await fetch('/api/workflow/undo-image', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ session_id: sessionId, scene_index: sceneIndex })
                });
                
                if (!res.ok) {
                    const errText = await res.text();
                    throw new Error(`되돌리기 실패 (${res.status}): ${errText}`);
                }
                
                const data = await res.json();
                if (data.success && data.image) {
                    updateSceneCard(sceneIndex, 'done', data.image);
                    showToast('이전 이미지로 복원되었습니다', 'success');
                    
                    // 남은 히스토리가 없으면 버튼 숨김
                    if (data.remaining_history <= 0) {
                        undoBtn.style.display = 'none';
                    }
                }
            } catch (e) {
                showToast('되돌리기 실패: ' + e.message, 'error');
            } finally {
                undoBtn.innerText = origText;
                undoBtn.disabled = false;
            }
        }

        // --- 캡션 생성 (편집 → 발행) ---
        async function generateCaption() {
            // 먼저 발행 탭으로 이동하여 로딩 UI 표시
            goToStep(5);
            const loadingEl = document.getElementById('loading-caption');
            const captionArea = document.getElementById('caption-publish-area');
            loadingEl.style.display = 'block';
            if (captionArea) captionArea.style.display = 'none';

            try {
                const res = await fetch('/api/workflow/generate-caption', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ session_id: sessionId })
                });
                const data = await res.json();
                const caption = data.caption;

                // Step 7 입력 필드 세팅
                document.getElementById('final-hook').value = caption.hook || '';
                document.getElementById('final-body').value = caption.body || '';
                document.getElementById('final-tip').value = caption.expert_tip || caption.tip || '';
                document.getElementById('final-hashtags').value = (caption.hashtags || []).join(' ');

                loadingEl.style.display = 'none';
                if (captionArea) captionArea.style.display = 'grid';
                initPublishSeriesTabs();
                updateInstaPreview();
            } catch (e) {
                showToast('캡션 생성 오류: ' + e.message, 'error');
                loadingEl.style.display = 'none';
                if (captionArea) captionArea.style.display = 'grid';
            }
        }

        // ============================================
        // 발행 탭: 시리즈 선택 + 다운로드 + 캡션 복사
        // ============================================
        var publishCurrentSeries = 0;

        function initPublishSeriesTabs() {
            var tabsEl = document.getElementById('publish-series-tabs');
            var btnsEl = document.getElementById('publish-series-tab-btns');
            var tbcOption = document.getElementById('tbc-option');
            if (!tabsEl || !btnsEl) return;
            if (seriesConfig.total <= 1) {
                tabsEl.style.display = 'none';
                if (tbcOption) tbcOption.style.display = 'none';
                publishCurrentSeries = 0;
                return;
            }
            tabsEl.style.display = 'block';
            // 시리즈 2편 이상일 때 "다음편에 계속" 옵션 표시
            if (tbcOption) tbcOption.style.display = 'block';
            var html = '<button class="btn btn-primary" style="font-size:0.8rem; padding:5px 12px;" onclick="selectPublishSeries(0)">전체</button>';
            for (var i = 0; i < seriesConfig.total; i++) {
                var sc = seriesConfig.scenesPerSeries[i] || 0;
                html += '<button class="btn btn-secondary" style="font-size:0.8rem; padding:5px 12px;" onclick="selectPublishSeries(' + (i+1) + ')">시리즈 ' + (i+1) + ' (' + sc + '장)</button>';
            }
            btnsEl.innerHTML = html;
            selectPublishSeries(0);
        }

        function selectPublishSeries(seriesNum) {
            publishCurrentSeries = seriesNum;
            var btns = document.querySelectorAll('#publish-series-tab-btns button');
            btns.forEach(function(btn, idx) {
                btn.className = (idx === seriesNum) ? 'btn btn-primary' : 'btn btn-secondary';
                btn.style.fontSize = '0.8rem';
                btn.style.padding = '5px 12px';
            });
            updateInstaPreviewForSeries();
        }

        function getSeriesImages() {
            var allImgs = document.querySelectorAll('#images-container img');
            if (publishCurrentSeries === 0 || seriesConfig.total <= 1) return Array.from(allImgs);
            var epIdx = publishCurrentSeries - 1;
            var start = 0;
            for (var i = 0; i < epIdx; i++) start += (seriesConfig.scenesPerSeries[i] || 0);
            var count = seriesConfig.scenesPerSeries[epIdx] || 0;
            return Array.from(allImgs).slice(start, start + count);
        }

        function updateInstaPreviewForSeries() {
            var imgs = getSeriesImages();
            var previewImg = document.getElementById('insta-preview-img');
            var indexEl = document.getElementById('insta-carousel-index');
            if (imgs.length > 0 && previewImg) previewImg.src = imgs[0].src;
            if (indexEl) indexEl.innerText = '1 / ' + imgs.length;
        }

        function downloadSeriesImages() {
            var imgs = getSeriesImages();
            if (!imgs.length) { showToast('다운로드할 이미지가 없습니다.', 'warning'); return; }
            var prefix = publishCurrentSeries > 0 ? 'series' + publishCurrentSeries + '_' : '';
            imgs.forEach(function(img, i) {
                var a = document.createElement('a');
                a.href = img.src;
                a.download = prefix + 'scene_' + (i + 1) + '.png';
                a.click();
            });
            showToast(imgs.length + '개 이미지 다운로드 시작', 'success');
        }

        function copyCaptionToClipboard() {
            var hook = document.getElementById('final-hook').value || '';
            var body = document.getElementById('final-body').value || '';
            var tip = document.getElementById('final-tip').value || '';
            var hashtags = document.getElementById('final-hashtags').value || '';
            var fullText = hook + '\n\n' + body;
            if (tip) fullText += '\n\n💡 ' + tip;
            if (hashtags) fullText += '\n\n' + hashtags;
            navigator.clipboard.writeText(fullText.trim()).then(function() {
                showToast('캡션이 클립보드에 복사되었습니다', 'success');
            }).catch(function() {
                var ta = document.createElement('textarea');
                ta.value = fullText.trim();
                document.body.appendChild(ta);
                ta.select();
                document.execCommand('copy');
                document.body.removeChild(ta);
                showToast('캡션이 클립보드에 복사되었습니다', 'success');
            });
        }

        function updateInstaPreview() {
            const hook = document.getElementById('final-hook').value;
            const body = document.getElementById('final-body').value;
            const tip = document.getElementById('final-tip').value;
            const hashtags = document.getElementById('final-hashtags').value;

            const fullText = `${hook}\n\n${body}\n\n💡 Tip: ${tip}`;
            document.getElementById('insta-preview-caption-text').innerText = fullText;
            document.getElementById('insta-preview-hashtags').innerText = hashtags;

            // 이미지 프리셋 (첫 번째 이미지 표시)
            const firstImg = document.querySelector('#images-container img');
            if (firstImg) {
                document.getElementById('insta-preview-img').src = firstImg.src;
            }

            const totalImages = document.querySelectorAll('#images-container img').length;
            document.getElementById('insta-carousel-index').innerText = `1 / ${totalImages}`;
        }

        async function publishToInstagram() {
            if (!sessionId) { showToast('세션이 없습니다.', 'error'); return; }
            const hook = document.getElementById('final-hook').value || '';
            const body = document.getElementById('final-body').value || '';
            const tip = document.getElementById('final-tip').value || '';
            const hashtags = document.getElementById('final-hashtags').value || '';
            const caption = `${hook}\n\n${body}\n\n💡 ${tip}`.trim() + (hashtags ? '\n\n' + hashtags.trim() : '');

            // 현재 시리즈 선택에 따른 이미지 URL 수집
            const seriesImgs = getSeriesImages();
            const imageUrls = seriesImgs.map(img => img.src).filter(src => src && src.startsWith('http'));

            if (!confirm(`${seriesImgs.length}장의 이미지를 인스타그램에 발행합니다. 계속할까요?`)) return;

            try {
                const res = await fetch('/api/workflow/publish', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        session_id: sessionId, 
                        caption: caption, 
                        images: imageUrls,
                        target_series: publishCurrentSeries > 0 ? publishCurrentSeries : null
                    })
                });
                const data = await res.json();
                if (data.success) {
                    showToast('인스타그램 발행 완료!', 'success');
                } else {
                    showToast('발행 실패: ' + (data.error || '알 수 없음'), 'error');
                }
            } catch (e) {
                showToast('발행 오류: ' + e.message, 'error');
            }
        }

        // 발행 탭 진입 시 Instagram 연결 상태 확인
        async function checkPublishConnection() {
            // Instagram 계정 정보 표시
            const infoCard = document.getElementById('publish-account-info');
            if (infoCard) {
                try {
                    const res = await fetch('/api/sns/instagram/verify');
                    const data = await res.json();
                    infoCard.style.display = 'block';
                    if (data.ok) {
                        const username = data.username || '';
                        document.getElementById('pub-ig-name').innerText = username ? `@${username}` : '연결됨';
                        let detail = data.permanent ? '🔒 영구 토큰' : '⏱️ 장기 토큰';
                        document.getElementById('pub-ig-detail').innerText = `${detail} · 발행하면 이 계정에 올라갑니다`;
                        if (data.profile_picture) {
                            document.getElementById('pub-ig-pic').innerHTML = 
                                `<img src="${data.profile_picture}" style="width:100%;height:100%;object-fit:cover;">`;
                        }
                        // Instagram 바로가기 링크
                        const igLink = document.getElementById('pub-ig-link');
                        if (igLink && username) {
                            igLink.href = `https://www.instagram.com/${username}/`;
                            igLink.style.display = 'inline-block';
                        }
                    } else {
                        document.getElementById('pub-ig-name').innerText = '⚠️ Instagram 미연결';
                        document.getElementById('pub-ig-detail').innerText = '설정 페이지에서 연결해주세요';
                    }
                } catch(e) {
                    infoCard.style.display = 'none';
                }
            }
        }

        async function toggleToBeContinued() {
            if (!sessionId) return;
            const enabled = document.getElementById('tbc-toggle').checked;
            const style = document.getElementById('tbc-style').value;
            const slider = document.getElementById('tbc-slider');
            if (slider) slider.style.left = enabled ? '18px' : '2px';
            if (slider) slider.parentElement.previousElementSibling.style.background = enabled ? 'var(--primary)' : 'var(--border)';
            
            try {
                const res = await fetch('/api/workflow/to-be-continued/apply', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        session_id: sessionId,
                        enabled: enabled,
                        style: style,
                        text: '다음편에 계속 →'
                    })
                });
                const data = await res.json();
                if (data.success) {
                    if (enabled && data.applied_count > 0) {
                        showToast(`"다음편에 계속" ${data.applied_count}개 편에 적용 완료`, 'success');
                    } else if (!enabled) {
                        showToast('"다음편에 계속" 해제됨', 'info');
                    } else {
                        showToast('적용할 이미지가 없습니다 (이미지 생성 후 시도하세요)', 'warning');
                    }
                } else {
                    showToast(data.reason || '적용 실패', 'warning');
                }
            } catch(e) {
                showToast('오류: ' + e.message, 'error');
            }
        }

        async function schedulePublish() {
            if (!sessionId) { showToast('세션이 없습니다.', 'error'); return; }
            const dtInput = document.getElementById('schedule-datetime');
            if (!dtInput || !dtInput.value) {
                showToast('예약 발행 날짜/시간을 선택해주세요.', 'warning');
                return;
            }
            const scheduledDate = new Date(dtInput.value);
            const now = new Date();
            // 최소 10분 뒤
            if (scheduledDate.getTime() - now.getTime() < 10 * 60 * 1000) {
                showToast('예약 시간은 현재로부터 최소 10분 이후여야 합니다.', 'warning');
                return;
            }
            // 최대 75일
            if (scheduledDate.getTime() - now.getTime() > 75 * 24 * 60 * 60 * 1000) {
                showToast('예약 시간은 최대 75일 이내여야 합니다.', 'warning');
                return;
            }

            const unixTs = Math.floor(scheduledDate.getTime() / 1000);
            const hook = document.getElementById('final-hook').value || '';
            const body = document.getElementById('final-body').value || '';
            const tip = document.getElementById('final-tip').value || '';
            const hashtags = document.getElementById('final-hashtags').value || '';
            const caption = `${hook}\n\n${body}\n\n💡 ${tip}`.trim() + (hashtags ? '\n\n' + hashtags.trim() : '');

            const seriesImgs = getSeriesImages();
            const imageUrls = seriesImgs.map(img => img.src).filter(src => src && src.startsWith('http'));

            const timeStr = scheduledDate.toLocaleString('ko-KR');
            if (!confirm(`${seriesImgs.length}장의 이미지를 ${timeStr}에 예약 발행합니다. 계속할까요?`)) return;

            try {
                const res = await fetch('/api/workflow/publish', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        session_id: sessionId,
                        caption: caption,
                        images: imageUrls,
                        target_series: publishCurrentSeries > 0 ? publishCurrentSeries : null,
                        scheduled_publish_time: unixTs
                    })
                });
                const data = await res.json();
                if (data.success) {
                    showToast(`📅 ${timeStr}에 예약 발행 등록 완료!`, 'success');
                    dtInput.value = '';
                } else {
                    showToast('예약 발행 실패: ' + (data.error || '알 수 없음'), 'error');
                }
            } catch (e) {
                showToast('예약 발행 오류: ' + e.message, 'error');
            }
        }

        // --- 유틸리티 ---
        function goToStep(step) {
            currentStep = step;
            // 모든 step-content를 확실하게 숨김 (인라인 display 완전 초기화)
            document.querySelectorAll('.step-content').forEach(c => {
                c.classList.remove('active');
                c.style.display = 'none';
            });
            // 타겟 step만 표시
            const targetEl = document.getElementById(`step-${step}`);
            if (targetEl) {
                targetEl.classList.add('active');
                targetEl.style.display = 'block';
            }

            // 프리셋 탭은 별도 처리 (번호가 아닌 'preset')
            document.querySelectorAll('.step').forEach(s => {
                const sStep = s.dataset.step;
                s.classList.remove('active', 'done');
                if (sStep === 'preset') {
                    if (step === 'preset') s.classList.add('active');
                } else {
                    const sNum = parseInt(sStep);
                    if (typeof step === 'number') {
                        if (sNum < step) s.classList.add('done');
                        if (sNum === step) s.classList.add('active');
                    }
                }
            });

            // --- VIEW STATE MANAGEMENT ---
            // Step 2: 자료 수집
            if (step === 2) {
                document.getElementById('loading-data').style.display = 'none';
                document.getElementById('data-review-area').style.display = 'block';
                document.getElementById('data-actions').style.display = 'flex';
                if (collectedData.length === 0) loadDataFromStorage();
                renderDataItems();
            }

            // Step 3: 스토리+이미지
            if (step === 3) {
                document.getElementById('loading-story').style.display = 'none';
                document.getElementById('story-review-area').style.display = 'block';
                document.getElementById('story-actions').style.display = 'flex';
                // 스토리가 있으면 저장 영역도 표시
                const saveAreaEl = document.getElementById('story-save-area');
                if (saveAreaEl) saveAreaEl.style.display = storyData ? 'flex' : 'none';
                if (storyData && storyData.scenes) {
                    renderCharacters();
                    renderScenes(storyData.scenes);
                }
                // 편집 버튼: 이미지가 1개 이상 있을 때만 활성화
                const editBtn = document.getElementById('btn-to-edit');
                if (editBtn) {
                    const hasImages = window._sceneImages && Object.keys(window._sceneImages).length > 0;
                    editBtn.disabled = !hasImages;
                    editBtn.title = hasImages ? '' : '먼저 이미지를 생성하세요';
                }
                // 프리셋 갤러리 로드
                if (typeof refreshStoryPresetSelector === 'function') refreshStoryPresetSelector();
            }

            // Step 3: 이미지 생성 컨트롤 바 표시 (스토리가 있을 때)
            if (step === 3 && storyData && storyData.scenes && storyData.scenes.length > 0) {
                const genBar = document.getElementById('gen-control-bar');
                if (genBar) genBar.style.display = 'block';
            }

            // Step 4: 말풍선 편집
            if (step === 4) {
                initBubbleEditor();
            }

            // Step 5: 캡션 + 발행
            if (step === 5) {
                updateInstaPreview();
                if (typeof checkPublishConnection === 'function') checkPublishConnection();
            }

            // 프리셋 탭
            if (step === 'preset') {
                if (typeof loadPresetGallery === 'function') loadPresetGallery();
            }
        }

        function navigateToStep(step) {
            goToStep(step);
        }

        // ============================================
        // ============================================
        // Step 6: 비파괴 말풍선 편집 시스템 (Non-destructive Bubble Editor)
        // ============================================

        let bubbleLayers = [];       // 전체 씬 말풍선 데이터
        let bubbleCurrentScene = 0;  // 현재 보고 있는 씬 인덱스 (0-based)
        let bubbleImages = [];       // 이미지 경로 배열
        let bubbleHistory = {};      // 씬별 되돌리기 히스토리 { sceneIdx: [ snapshot, ... ] }

        // 말풍선 모양 → CSS 스타일
        const SHAPE_CSS = {
            "round":     { borderRadius: "18px", border: "2px solid", label: "둥근" },
            "round-lg":  { borderRadius: "28px", border: "2px solid", label: "큰둥근" },
            "square":    { borderRadius: "6px", border: "2px solid", label: "사각" },
            "shout":     { borderRadius: "4px", border: "3px solid", fontWeight: "700", label: "강조" },
            "spike":     { borderRadius: "2px", border: "3px solid", boxShadow: "2px 2px 0 #333", fontWeight: "700", label: "외침" },
            "thought":   { borderRadius: "24px", border: "2px dashed", fontStyle: "italic", label: "생각" },
            "cloud":     { borderRadius: "40% 40% 40% 40% / 50% 50% 35% 35%", border: "2px solid", padding: "12px 18px", label: "구름" },
            "whisper":   { borderRadius: "14px", border: "1px dashed", opacity: "0.8", fontStyle: "italic", label: "속삭임" },
            "comic":     { borderRadius: "50%", border: "3px solid", padding: "10px 14px", label: "만화" },
            "narration": { borderRadius: "0", border: "none", label: "나레이션" },
        };

        // 9-Grid → 퍼센트 좌표로 마이그레이션 (기존 데이터 호환)
        const POSITION_TO_PERCENT = {
            "top-left":      { x: 5, y: 3 },
            "top-center":    { x: 25, y: 3 },
            "top-right":     { x: 55, y: 3 },
            "middle-left":   { x: 5, y: 35 },
            "middle-center": { x: 25, y: 35 },
            "middle-right":  { x: 55, y: 35 },
            "bottom-left":   { x: 5, y: 65 },
            "bottom-center": { x: 15, y: 78 },
            "bottom-right":  { x: 55, y: 65 },
        };

        // 말풍선 데이터 마이그레이션: 기존 position 문자열 → x,y,w,h 퍼센트 + 필드명 호환
        function migrateBubbleData(bubble) {
            if (bubble.x == null || bubble.y == null) {
                const pos = POSITION_TO_PERCENT[bubble.position] || { x: 25, y: 10 };
                bubble.x = pos.x;
                bubble.y = pos.y;
            }
            if (bubble.w == null) bubble.w = bubble.type === 'narration' ? 90 : 40;
            if (bubble.h == null) bubble.h = bubble.type === 'narration' ? 10 : 16;
            // 서버 tail_direction → 프론트 tail 매핑
            if (bubble.tail == null && bubble.tail_direction) {
                bubble.tail = bubble.tail_direction;
            }
            if (!bubble.tail) bubble.tail = 'none';
        }

        // 드래그 상태 관리
        let bubbleDragState = null;

        function goToEditStage() { goToStep(4); }

        // ★ 편집 탭 진입 시 초기화
        async function initBubbleEditor() {
            if (!sessionId) return;

            // 이미지 목록 수집 (step 5에서 생성된 이미지)
            bubbleImages = [];
            try {
                const res = await fetch(`/api/workflow/session/${sessionId}`);
                if (res.ok) {
                    const data = await res.json();
                    if (data.images) {
                        bubbleImages = data.images.map(img => ({
                            scene_number: img.scene_number,
                            path: img.local_path || img.image_url || ''
                        }));
                    }
                }
            } catch(e) {
                console.warn("세션 이미지 로드 실패, 대체 로직 사용");
            }

            // 먼저 서버에 기존 레이어가 있는지 확인 (GET)
            let hasExistingLayers = false;
            try {
                const getRes = await fetch(`/api/workflow/bubble-layers/${sessionId}`);
                const getData = await getRes.json();
                if (getData.layers && getData.layers.length > 0) {
                    bubbleLayers = getData.layers;
                    hasExistingLayers = true;
                }
            } catch(e) {}

            // 기존 레이어가 없을 때만 초기화 (새로 생성)
            if (!hasExistingLayers) {
                try {
                    const initRes = await fetch(`/api/workflow/bubble-layers/${sessionId}/init`, { method: 'POST' });
                    const initData = await initRes.json();
                    if (initData.success) {
                        bubbleLayers = initData.layers;
                    }
                } catch(e) {
                    console.error("말풍선 레이어 초기화 실패:", e);
                }
            }

            // 마이그레이션: 기존 데이터의 x,y,w,h 보정
            bubbleLayers.forEach(layer => {
                if (layer.bubbles) layer.bubbles.forEach(b => migrateBubbleData(b));
            });

            bubbleCurrentScene = 0;
            renderBubbleEditor();
        }

        // ★ 메인 렌더링 함수
        function renderBubbleEditor() {
            if (!bubbleLayers.length && !bubbleImages.length) {
                document.getElementById('bubble-scene-indicator').innerText = '이미지 없음';
                return;
            }

            const total = Math.max(bubbleLayers.length, bubbleImages.length);
            const idx = bubbleCurrentScene;

            // 네비게이션 표시
            document.getElementById('bubble-scene-indicator').innerText = `씬 ${idx + 1} / ${total}`;
            document.getElementById('bubble-prev-btn').disabled = idx <= 0;
            document.getElementById('bubble-next-btn').disabled = idx >= total - 1;

            // 이미지 표시
            const imgEl = document.getElementById('bubble-preview-img');
            const imgData = bubbleImages[idx];
            if (imgData && imgData.path) {
                imgEl.src = imgData.path.startsWith('/') ? imgData.path : '/' + imgData.path;
            } else {
                imgEl.src = '';
            }

            // 현재 레이어
            const layer = bubbleLayers[idx] || { bubbles: [], show_all: true, font_family: "Nanum Gothic" };

            // 전체 표시 체크박스
            document.getElementById('bubble-show-all').checked = layer.show_all !== false;

            // CSS 오버레이 렌더링
            renderCSSOverlay(layer);

            // 편집 카드 렌더링
            renderBubbleEditCards(layer);
        }

        // ★ CSS 실시간 프리뷰 — 자유 위치 + 드래그 이동 + 리사이즈
        function renderCSSOverlay(layer) {
            const container = document.getElementById('bubble-overlay-layer');
            container.innerHTML = '';
            container.style.pointerEvents = 'none';

            if (!layer.show_all) return;

            const fontFamily = layer.font_family || "Nanum Gothic";

            layer.bubbles.forEach((bubble, i) => {
                if (!bubble.visible || !bubble.text) return;
                migrateBubbleData(bubble);

                const shapeCSS = SHAPE_CSS[bubble.shape] || SHAPE_CSS["round"];
                const isNarr = bubble.type === 'narration';
                const isBold = bubble.bold || shapeCSS.fontWeight;

                const div = document.createElement('div');
                div.dataset.bubbleIdx = i;
                const bubblePadding = shapeCSS.padding || '6px 10px';
                div.style.cssText = `
                    position: absolute; pointer-events: auto; cursor: move;
                    left: ${bubble.x}%; top: ${bubble.y}%;
                    width: ${bubble.w}%; min-height: ${bubble.h}%;
                    padding: ${bubblePadding}; box-sizing: border-box;
                    font-family: '${fontFamily}', sans-serif;
                    font-size: ${bubble.font_size || 13}px; line-height: 1.35;
                    background: ${isNarr ? 'rgba(0,0,0,0.7)' : (bubble.bg_color || '#FFF')};
                    color: ${isNarr ? '#fff' : (bubble.text_color || '#000')};
                    border-color: ${bubble.border_color || '#333'};
                    opacity: ${bubble.opacity || (shapeCSS.opacity ? parseFloat(shapeCSS.opacity) : 0.95)};
                    z-index: ${10 + i};
                    ${isNarr ? 'border: none;' : (shapeCSS.border || '')};
                    border-radius: ${isNarr ? '0' : (shapeCSS.borderRadius || '18px')};
                    font-weight: ${isBold ? '700' : '400'};
                    ${shapeCSS.fontStyle ? 'font-style:'+shapeCSS.fontStyle+';' : ''}
                    box-shadow: ${shapeCSS.boxShadow || '0 2px 8px rgba(0,0,0,0.15)'};
                    word-break: keep-all; overflow: hidden;
                    text-align: ${isNarr ? 'center' : 'left'};
                    display: flex; align-items: center; justify-content: center;
                    user-select: none;
                `;

                // 대사 텍스트만 (캐릭터 이름 표시하지 않음)
                div.innerText = bubble.text;

                // 말풍선 꼬리(tail) 렌더링
                if (!isNarr && bubble.tail && bubble.tail !== 'none') {
                    const tail = document.createElement('div');
                    const tailColor = bubble.bg_color || '#FFF';
                    const tailBorder = bubble.border_color || '#333';
                    const tailSize = 10;
                    let tailCSS = 'position:absolute; width:0; height:0; pointer-events:none;';
                    
                    switch (bubble.tail) {
                        case 'bottom-left':
                            tailCSS += `bottom:-${tailSize}px; left:15%;
                                border-left: ${tailSize}px solid transparent;
                                border-right: ${tailSize}px solid transparent;
                                border-top: ${tailSize}px solid ${tailColor};`;
                            break;
                        case 'bottom-center':
                            tailCSS += `bottom:-${tailSize}px; left:50%; transform:translateX(-50%);
                                border-left: ${tailSize}px solid transparent;
                                border-right: ${tailSize}px solid transparent;
                                border-top: ${tailSize}px solid ${tailColor};`;
                            break;
                        case 'bottom-right':
                            tailCSS += `bottom:-${tailSize}px; right:15%;
                                border-left: ${tailSize}px solid transparent;
                                border-right: ${tailSize}px solid transparent;
                                border-top: ${tailSize}px solid ${tailColor};`;
                            break;
                        case 'top-left':
                            tailCSS += `top:-${tailSize}px; left:15%;
                                border-left: ${tailSize}px solid transparent;
                                border-right: ${tailSize}px solid transparent;
                                border-bottom: ${tailSize}px solid ${tailColor};`;
                            break;
                        case 'top-center':
                            tailCSS += `top:-${tailSize}px; left:50%; transform:translateX(-50%);
                                border-left: ${tailSize}px solid transparent;
                                border-right: ${tailSize}px solid transparent;
                                border-bottom: ${tailSize}px solid ${tailColor};`;
                            break;
                        case 'top-right':
                            tailCSS += `top:-${tailSize}px; right:15%;
                                border-left: ${tailSize}px solid transparent;
                                border-right: ${tailSize}px solid transparent;
                                border-bottom: ${tailSize}px solid ${tailColor};`;
                            break;
                        case 'left':
                            tailCSS += `left:-${tailSize}px; top:50%; transform:translateY(-50%);
                                border-top: ${tailSize}px solid transparent;
                                border-bottom: ${tailSize}px solid transparent;
                                border-right: ${tailSize}px solid ${tailColor};`;
                            break;
                        case 'right':
                            tailCSS += `right:-${tailSize}px; top:50%; transform:translateY(-50%);
                                border-top: ${tailSize}px solid transparent;
                                border-bottom: ${tailSize}px solid transparent;
                                border-left: ${tailSize}px solid ${tailColor};`;
                            break;
                    }
                    tail.style.cssText = tailCSS;
                    div.appendChild(tail);
                }

                // 드래그 이동 이벤트
                div.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('bubble-resize-handle')) return;
                    e.preventDefault();
                    const rect = container.getBoundingClientRect();
                    bubbleDragState = {
                        type: 'move', idx: i,
                        startMouseX: e.clientX, startMouseY: e.clientY,
                        startX: bubble.x, startY: bubble.y,
                        containerW: rect.width, containerH: rect.height
                    };
                    highlightEditCard(i);
                });

                // 리사이즈 핸들 (우하단)
                const handle = document.createElement('div');
                handle.className = 'bubble-resize-handle';
                handle.style.cssText = `
                    position: absolute; right: -3px; bottom: -3px;
                    width: 14px; height: 14px; cursor: nwse-resize;
                    background: var(--primary); border-radius: 2px;
                    opacity: 0; transition: opacity 0.15s;
                    pointer-events: auto;
                `;
                handle.addEventListener('mousedown', (e) => {
                    e.preventDefault(); e.stopPropagation();
                    const rect = container.getBoundingClientRect();
                    bubbleDragState = {
                        type: 'resize', idx: i,
                        startMouseX: e.clientX, startMouseY: e.clientY,
                        startW: bubble.w, startH: bubble.h,
                        containerW: rect.width, containerH: rect.height
                    };
                    highlightEditCard(i);
                });

                div.appendChild(handle);

                // 호버 시 핸들 표시
                div.addEventListener('mouseenter', () => { handle.style.opacity = '0.8'; });
                div.addEventListener('mouseleave', () => { if (!bubbleDragState) handle.style.opacity = '0'; });

                container.appendChild(div);
            });
        }

        // 전역 마우스 이벤트 (드래그 이동 + 리사이즈)
        document.addEventListener('mousemove', (e) => {
            if (!bubbleDragState) return;
            const s = bubbleDragState;
            const layer = bubbleLayers[bubbleCurrentScene];
            if (!layer) return;
            const bubble = layer.bubbles[s.idx];
            if (!bubble) return;

            const dx = ((e.clientX - s.startMouseX) / s.containerW) * 100;
            const dy = ((e.clientY - s.startMouseY) / s.containerH) * 100;

            if (s.type === 'move') {
                bubble.x = Math.max(0, Math.min(100 - bubble.w, s.startX + dx));
                bubble.y = Math.max(0, Math.min(95, s.startY + dy));
            } else if (s.type === 'resize') {
                bubble.w = Math.max(10, Math.min(95, s.startW + dx));
                bubble.h = Math.max(5, Math.min(80, s.startH + dy));
            }

            renderCSSOverlay(layer);
        });

        document.addEventListener('mouseup', () => {
            if (bubbleDragState) {
                bubbleDragState = null;
            }
        });

        // ★ 편집 카드 렌더링 — 자유 위치 + 대사 편집
        function renderBubbleEditCards(layer) {
            const container = document.getElementById('bubble-edit-cards');
            container.innerHTML = '';

            layer.bubbles.forEach((bubble, i) => {
                migrateBubbleData(bubble);
                const card = document.createElement('div');
                card.id = `bubble-card-${i}`;
                card.style.cssText = `
                    background: var(--bg); border: 2px solid var(--border); border-radius: 8px;
                    padding: 0.6rem; transition: border-color 0.2s; cursor: pointer;
                `;
                card.onclick = (e) => {
                    if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT' || e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON') return;
                    highlightEditCard(i);
                };

                const isNarr = bubble.type === 'narration';
                const typeLabel = isNarr ? '📖 나레이션' : '💬 대사';
                const typeColor = isNarr ? 'var(--warning)' : (bubble.bg_color || '#fff');

                const boldChecked = bubble.bold ? 'checked' : '';
                const shapeOptions = Object.entries(SHAPE_CSS)
                    .filter(([k]) => k !== 'narration')
                    .map(([k, v]) => `<option value="${k}" ${bubble.shape===k?'selected':''}>${v.label}</option>`)
                    .join('');

                card.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.4rem;">
                        <span style="font-size: 0.8rem; font-weight: 700; display: flex; align-items: center; gap: 4px;">
                            <span style="display: inline-block; width: 10px; height: 10px; border-radius: 50%; background: ${typeColor}; border: 1px solid #666;"></span>
                            ${typeLabel}${bubble.character ? ` <span style="font-weight:400; color:var(--text-muted); font-size:0.7rem;">(${bubble.character})</span>` : ''}
                        </span>
                        <div style="display: flex; gap: 4px; align-items: center;">
                            <button onclick="toggleBubbleVisible(${i})" title="${bubble.visible ? '숨기기' : '보이기'}"
                                style="background:none; border:none; cursor:pointer; font-size: 0.9rem; opacity: ${bubble.visible ? 1 : 0.4};">
                                ${bubble.visible ? '👁' : '🚫'}
                            </button>
                            <button onclick="removeBubble(${i})" title="삭제"
                                style="background:none; border:none; cursor:pointer; font-size: 0.9rem; color: var(--danger);">✕</button>
                        </div>
                    </div>

                    <!-- 대사 텍스트 편집 -->
                    <textarea onchange="updateBubbleText(${i}, this.value)" oninput="livePreviewText(${i}, this.value)"
                        style="width: 100%; min-height: 38px; font-size: 0.8rem; border: 1px solid var(--border); border-radius: 6px; padding: 6px; resize: vertical; background: var(--bg-input); color: var(--text);"
                    >${bubble.text || ''}</textarea>

                    <!-- 1행: 모양 + 글꼴 크기 + 볼드 -->
                    <div style="display: flex; gap: 0.35rem; margin-top: 0.35rem; align-items: center;">
                        <select onchange="updateBubbleShape(${i}, this.value)" style="font-size: 0.7rem; padding: 2px 4px; flex: 1;" title="말풍선 모양">
                            ${shapeOptions}
                        </select>
                        <select onchange="updateBubbleFontSize(${i}, this.value)" style="font-size: 0.7rem; padding: 2px 4px; width:42px;" title="글자 크기">
                            ${[9,10,11,12,13,14,15,16,18,20,22,24].map(s => `<option value="${s}" ${(bubble.font_size||13)==s?'selected':''}>${s}</option>`).join('')}
                        </select>
                        <label style="font-size:0.7rem; display:flex; align-items:center; gap:2px; cursor:pointer; white-space:nowrap;" title="볼드 처리">
                            <input type="checkbox" ${boldChecked} onchange="toggleBubbleBold(${i}, this.checked)"> <b>B</b>
                        </label>
                    </div>

                    <!-- 2행: 색상 + 꼬리 방향 -->
                    <div style="display: flex; gap: 0.35rem; margin-top: 0.3rem; align-items: center; flex-wrap:wrap;">
                        <span style="font-size:0.65rem; color:var(--text-muted);">배경</span>
                        <input type="color" value="${bubble.bg_color || '#FFFFFF'}" title="배경색"
                               onchange="updateBubbleColor(${i}, 'bg_color', this.value)"
                               style="width:22px; height:18px; border:none; padding:0; cursor:pointer;">
                        <span style="font-size:0.65rem; color:var(--text-muted);">글자</span>
                        <input type="color" value="${bubble.text_color || '#000000'}" title="글자색"
                               onchange="updateBubbleColor(${i}, 'text_color', this.value)"
                               style="width:22px; height:18px; border:none; padding:0; cursor:pointer;">
                        <span style="font-size:0.65rem; color:var(--text-muted);">테두리</span>
                        <input type="color" value="${bubble.border_color || '#333333'}" title="테두리색"
                               onchange="updateBubbleColor(${i}, 'border_color', this.value)"
                               style="width:22px; height:18px; border:none; padding:0; cursor:pointer;">
                        <span style="font-size:0.65rem; color:var(--text-muted); margin-left:2px;">꼬리</span>
                        <select onchange="updateBubbleTail(${i}, this.value)" style="font-size:0.65rem; padding:1px 3px;" title="꼬리 방향">
                            <option value="none" ${(!bubble.tail||bubble.tail==='none')?'selected':''}>없음</option>
                            <option value="bottom-left" ${bubble.tail==='bottom-left'?'selected':''}>↙ 좌하</option>
                            <option value="bottom-center" ${bubble.tail==='bottom-center'?'selected':''}>↓ 하</option>
                            <option value="bottom-right" ${bubble.tail==='bottom-right'?'selected':''}>↘ 우하</option>
                            <option value="top-left" ${bubble.tail==='top-left'?'selected':''}>↖ 좌상</option>
                            <option value="top-center" ${bubble.tail==='top-center'?'selected':''}>↑ 상</option>
                            <option value="top-right" ${bubble.tail==='top-right'?'selected':''}>↗ 우상</option>
                            <option value="left" ${bubble.tail==='left'?'selected':''}>← 좌</option>
                            <option value="right" ${bubble.tail==='right'?'selected':''}>→ 우</option>
                        </select>
                    </div>
                `;

                container.appendChild(card);
            });
        }

        // ── 네비게이션 ──
        function bubbleNav(dir) {
            const total = Math.max(bubbleLayers.length, bubbleImages.length);
            const next = bubbleCurrentScene + dir;
            if (next >= 0 && next < total) {
                saveBubbleLayerToServer(); // 현재 씬 저장
                bubbleCurrentScene = next;
                renderBubbleEditor();
            }
        }

        // ── 편집 함수들 ──
        function updateBubbleText(idx, text) {
            const layer = bubbleLayers[bubbleCurrentScene];
            if (layer && layer.bubbles[idx]) {
                saveSnapshot();
                layer.bubbles[idx].text = text;
                renderCSSOverlay(layer);
            }
        }

        function livePreviewText(idx, text) {
            const layer = bubbleLayers[bubbleCurrentScene];
            if (layer && layer.bubbles[idx]) {
                layer.bubbles[idx].text = text;
                renderCSSOverlay(layer);
            }
        }

        function updateBubbleColor(idx, prop, color) {
            const layer = bubbleLayers[bubbleCurrentScene];
            if (layer && layer.bubbles[idx]) {
                layer.bubbles[idx][prop] = color;
                renderCSSOverlay(layer);
            }
        }

        function updateBubbleShape(idx, shape) {
            const layer = bubbleLayers[bubbleCurrentScene];
            if (layer && layer.bubbles[idx]) {
                layer.bubbles[idx].shape = shape;
                renderCSSOverlay(layer);
            }
        }

        function updateBubbleFontSize(idx, size) {
            const layer = bubbleLayers[bubbleCurrentScene];
            if (layer && layer.bubbles[idx]) {
                layer.bubbles[idx].font_size = parseInt(size) || 15;
                renderCSSOverlay(layer);
            }
        }

        function toggleBubbleVisible(idx) {
            const layer = bubbleLayers[bubbleCurrentScene];
            if (layer && layer.bubbles[idx]) {
                layer.bubbles[idx].visible = !layer.bubbles[idx].visible;
                renderBubbleEditor();
            }
        }

        function removeBubble(idx) {
            const layer = bubbleLayers[bubbleCurrentScene];
            if (layer) {
                saveSnapshot();
                layer.bubbles.splice(idx, 1);
                renderBubbleEditor();
            }
        }

        function addNewBubble() {
            const layer = bubbleLayers[bubbleCurrentScene];
            if (!layer) return;
            saveSnapshot();
            const newId = `s${layer.scene_number}_new_${Date.now()}`;
            // 새 말풍선: 기본 위치를 약간 어긋나게 배치
            const offset = (layer.bubbles.length % 5) * 8;
            layer.bubbles.push({
                id: newId, type: "dialogue", character: "", text: "새 대사",
                position: "top-center", shape: "round",
                x: 10 + offset, y: 5 + offset, w: 40, h: 14,
                bg_color: "#FFFFFF", text_color: "#000000", border_color: "#333333",
                font_size: 13, visible: true, opacity: 0.95, bold: false
            });
            renderBubbleEditor();
        }

        // ── 되돌리기 (Undo) ──
        function saveSnapshot() {
            const idx = bubbleCurrentScene;
            const layer = bubbleLayers[idx];
            if (!layer) return;
            if (!bubbleHistory[idx]) bubbleHistory[idx] = [];
            // 최대 20개 히스토리
            if (bubbleHistory[idx].length >= 20) bubbleHistory[idx].shift();
            bubbleHistory[idx].push(JSON.parse(JSON.stringify(layer.bubbles)));
        }

        function undoBubbles() {
            const idx = bubbleCurrentScene;
            if (!bubbleHistory[idx] || bubbleHistory[idx].length === 0) {
                showToast('되돌릴 내용이 없습니다.', 'info');
                return;
            }
            const prev = bubbleHistory[idx].pop();
            const layer = bubbleLayers[idx];
            if (layer) {
                layer.bubbles = prev;
                renderBubbleEditor();
            }
        }

        function resetBubbles() {
            if (!confirm('이 씬의 말풍선을 초기 상태로 되돌릴까요?')) return;
            // 서버에서 다시 초기화
            initBubbleEditor();
        }

        // 편집 탭에서 씬 삭제
        async function deleteSceneFromEditor() {
            const total = Math.max(bubbleLayers.length, bubbleImages.length);
            if (total <= 1) {
                showToast('마지막 남은 씬은 삭제할 수 없습니다.', 'warning');
                return;
            }
            const sceneNum = bubbleCurrentScene + 1;
            if (!confirm(`씬 ${sceneNum}을 삭제하시겠습니까?\n이미지와 말풍선 데이터가 모두 삭제됩니다.`)) return;

            // 1. 말풍선 레이어 삭제
            if (bubbleCurrentScene < bubbleLayers.length) {
                bubbleLayers.splice(bubbleCurrentScene, 1);
            }
            // 2. 이미지 배열에서 삭제
            if (bubbleCurrentScene < bubbleImages.length) {
                bubbleImages.splice(bubbleCurrentScene, 1);
            }
            // 3. 스토리 데이터에서도 삭제
            if (storyData && storyData.scenes && bubbleCurrentScene < storyData.scenes.length) {
                storyData.scenes.splice(bubbleCurrentScene, 1);
                // 씬 번호 재정렬
                storyData.scenes.forEach((scene, index) => {
                    scene.scene_number = index + 1;
                });
            }
            // 4. 세션의 이미지 목록에서도 삭제 요청
            try {
                await fetch(`/api/workflow/session/${sessionId}/delete-scene/${sceneNum}`, { method: 'DELETE' });
            } catch(e) { console.warn('서버 씬 삭제 요청 실패:', e); }

            // 5. 씬 번호 재정렬 (레이어)
            bubbleLayers.forEach((layer, idx) => { layer.scene_number = idx + 1; });

            // 6. 현재 인덱스 조정
            const newTotal = Math.max(bubbleLayers.length, bubbleImages.length);
            if (bubbleCurrentScene >= newTotal) bubbleCurrentScene = Math.max(0, newTotal - 1);

            renderBubbleEditor();
            showToast(`씬 ${sceneNum} 삭제 완료`, 'success');
        }

        function toggleShowAll() {
            const layer = bubbleLayers[bubbleCurrentScene];
            if (layer) {
                layer.show_all = document.getElementById('bubble-show-all').checked;
                renderCSSOverlay(layer);
            }
        }

        // 볼드 토글 (개별)
        function toggleBubbleBold(idx, checked) {
            const layer = bubbleLayers[bubbleCurrentScene];
            if (layer && layer.bubbles[idx]) {
                layer.bubbles[idx].bold = checked;
                renderCSSOverlay(layer);
            }
        }

        function updateBubbleTail(idx, dir) {
            const layer = bubbleLayers[bubbleCurrentScene];
            if (layer && layer.bubbles[idx]) {
                layer.bubbles[idx].tail = dir;
                renderCSSOverlay(layer);
            }
        }

        // 글로벌 일괄적용 — 현재 씬의 모든 대사 말풍선에 적용
        function applyGlobalToAll() {
            const layer = bubbleLayers[bubbleCurrentScene];
            if (!layer) return;
            saveSnapshot();

            const shape = document.getElementById('bubble-global-shape').value;
            const font = document.getElementById('bubble-font-family').value;
            const textColor = document.getElementById('bubble-global-text-color').value;
            const bgColor = document.getElementById('bubble-global-bg-color').value;
            const bold = document.getElementById('bubble-global-bold').checked;

            layer.font_family = font;
            layer.bubbles.forEach(b => {
                if (b.type === 'dialogue') {
                    b.shape = shape;
                    b.text_color = textColor;
                    b.bg_color = bgColor;
                    b.bold = bold;
                }
            });
            renderBubbleEditor();
            showToast('전체 말풍선에 설정이 적용되었습니다.', 'success');
        }

        function onGlobalSettingChange() {
            const font = document.getElementById('bubble-font-family').value;
            const layer = bubbleLayers[bubbleCurrentScene];
            if (layer) {
                layer.font_family = font;
                renderCSSOverlay(layer);
            }
        }

        function highlightEditCard(idx) {
            document.querySelectorAll('[id^="bubble-card-"]').forEach(el => {
                el.style.borderColor = 'var(--border)';
            });
            const card = document.getElementById(`bubble-card-${idx}`);
            if (card) {
                card.style.borderColor = 'var(--primary)';
                card.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }

        // ── 서버 저장 ──
        async function saveBubbleLayerToServer() {
            const layer = bubbleLayers[bubbleCurrentScene];
            if (!layer || !sessionId) return;
            try {
                await fetch(`/api/workflow/bubble-layers/${sessionId}/${layer.scene_number}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        bubbles: layer.bubbles,
                        show_all: layer.show_all,
                        font_family: layer.font_family
                    })
                });
            } catch(e) { console.warn("말풍선 저장 실패:", e); }
        }

        // ── 최종 내보내기 ──
        async function exportWithBubbles() {
            if (!sessionId) { showToast('세션이 없습니다.', 'error'); return; }
            // 현재 씬 먼저 저장
            await saveBubbleLayerToServer();
            // 모든 씬 저장
            for (let i = 0; i < bubbleLayers.length; i++) {
                const layer = bubbleLayers[i];
                try {
                    await fetch(`/api/workflow/bubble-layers/${sessionId}/${layer.scene_number}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ bubbles: layer.bubbles, show_all: layer.show_all, font_family: layer.font_family })
                    });
                } catch(e) {}
            }

            const btn = document.getElementById('bubble-export-btn');
            btn.disabled = true; btn.innerText = '⏳ 내보내기 중...';

            try {
                const res = await fetch(`/api/workflow/bubble-layers/${sessionId}/export`, { method: 'POST' });
                const data = await res.json();
                if (data.success) {
                    btn.innerText = `✅ ${data.exported_count}장 내보내기 완료!`;
                    setTimeout(() => { btn.disabled = false; btn.innerText = '📥 최종 이미지 내보내기'; }, 3000);
                } else {
                    throw new Error(data.detail || '내보내기 실패');
                }
            } catch(e) {
                showToast('내보내기 실패: ' + e.message, 'error');
                btn.disabled = false; btn.innerText = '📥 최종 이미지 내보내기';
            }
        }

        // 톤 조절 기능 제거됨

        async function proceedFromEditStage() {
            // 모든 씬의 말풍선 레이어를 서버에 저장 (현재 씬뿐 아니라 전체)
            for (let i = 0; i < bubbleLayers.length; i++) {
                const layer = bubbleLayers[i];
                try {
                    await fetch(`/api/workflow/bubble-layers/${sessionId}/${layer.scene_number}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            bubbles: layer.bubbles,
                            show_all: layer.show_all,
                            font_family: layer.font_family
                        })
                    });
                } catch(e) { console.warn(`씬 ${layer.scene_number} 말풍선 저장 실패:`, e); }
            }
            generateCaption();
        }
    </script>
    <script>

        // --- Style System 2.0 Logic (커스텀 스타일 관리 기능 삭제됨) ---

        // --- Preview & Generation ---

        async function generatePreview() {
            // 이전 요청이 있으면 중단
            if (previewAbortController) {
                previewAbortController.abort();
            }
            previewAbortController = new AbortController();

            const btnManual = document.getElementById('btn-manual-apply');
            const btnCancel = document.getElementById('btn-preview-cancel');
            const manualResultContainer = document.getElementById('manual-preview-result');

            // Progress Timer Logic
            let seconds = 0;
            if (btnManual) { btnManual.disabled = true; btnManual.innerText = '생성 중...'; }
            if (btnCancel) { btnCancel.style.display = 'inline-flex'; }

            if (manualResultContainer) {
                manualResultContainer.style.display = 'flex';
                manualResultContainer.style.minHeight = '300px'; // Ensure enough space
            }

            // Initial loading state in preview container
            const updateLoadingState = (sec) => {
                const html = `
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: var(--text-muted); padding: 1rem;">
                        <div style="font-size: 2.5rem; margin-bottom: 1rem; animation: pulse 1.5s infinite;">🎨</div>
                        <div style="font-weight: 600; margin-bottom: 0.5rem;">AI가 그림을 그리고 있어요</div>
                        <div style="font-family: monospace; font-size: 1.4rem; color: var(--primary);">${sec.toFixed(1)}s</div>
                    </div>
                `;
                if (manualResultContainer) manualResultContainer.innerHTML = html;
            };

            updateLoadingState(0);

            const timerInterval = setInterval(() => {
                seconds += 0.1;
                updateLoadingState(seconds);
            }, 100);

            // 60초 넘어가면 안내 문구
            let longWaitShown = false;
            const longWaitInterval = setInterval(() => {
                if (seconds >= 60 && !longWaitShown && manualResultContainer) {
                    longWaitShown = true;
                    const wrap = manualResultContainer.querySelector('div');
                    if (wrap) {
                        const hint = document.createElement('div');
                        hint.style.cssText = 'margin-top:0.75rem; font-size:0.85rem; color:var(--warning);';
                        hint.textContent = '요청이 오래 걸리고 있습니다. API/네트워크 상태를 확인해보세요. 120초 초과 시 자동으로 중단됩니다.';
                        wrap.appendChild(hint);
                    }
                }
            }, 1000);

            // Cleanup helper
            const stopTimer = () => {
                clearInterval(timerInterval);
                clearInterval(longWaitInterval);
                if (btnManual) { btnManual.disabled = false; btnManual.innerText = '적용하여 다시 미리보기'; }
                if (btnCancel) { btnCancel.style.display = 'none'; }
                previewAbortController = null;
            };

            // 추가 지시사항 (있으면)
            const additionalEl = document.getElementById('manual-additional');
            const additionalPrompt = additionalEl ? additionalEl.value : '';

            // 프리셋 기반 — 별도 스타일 프롬프트 불필요
            const overrides = {
                character_style_prompt: "",
                background_style_prompt: "",
                style_prompt: "",
                additional_instructions: additionalPrompt
            };

            // Auto-create session if missing (for Preview-only usage)
            if (!sessionId) {
                try {
                    console.log("No session found, creating temporary session for preview...");
                    const startRes = await fetch('/api/workflow/start', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ mode: 'manual', keyword: 'Preview Session' })
                    });
                    const startData = await startRes.json();
                    if (startData.session_id) {
                        sessionId = startData.session_id;
                        localStorage.setItem('lastSessionId', sessionId); // Save for persistency
                        console.log("Temporary session created:", sessionId);
                    } else {
                        throw new Error("Failed to create temporary session");
                    }
                } catch (e) {
                    showToast('세션 생성 실패: ' + e.message, 'error');
                    btn.innerText = '샘플 미리보기 생성';
                    btn.disabled = false;
                    previewContainer.innerHTML = '<div style="color:red; padding:1rem;">Session Error</div>';
                    return;
                }
            }

            try {
                // 130초 타임아웃 (백엔드 120초보다 약간 길게)
                const timeoutId = setTimeout(() => { if (previewAbortController) previewAbortController.abort(); }, 130000);
                const res = await fetch('/api/workflow/generate-preview', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        session_id: sessionId,
                        character_style_id: null,
                        background_style_id: null,
                        trained_character_id: null,
                        sub_style: "",
                        manual_overrides: overrides,
                        model: 'nano-banana-pro' // Gemini 3.0 Preview 고정
                    }),
                    signal: previewAbortController.signal
                });
                clearTimeout(timeoutId);

                if (res.status === 404) {
                    console.warn("Session expired or not found (404). Creating new session and retrying...");
                    sessionId = null;
                    localStorage.removeItem('lastSessionId');
                    // Retry once
                    if (!window.isRetryingPreview) {
                        window.isRetryingPreview = true;
                        await generatePreview();
                        window.isRetryingPreview = false;
                        return;
                    } else {
                        throw new Error("Session creation failed even after retry.");
                    }
                }

                if (res.status === 200) {
                    const data = await res.json();
                    stopTimer();

                    if (data.success) {
                        let imgSrc = '';
                        if (data.image_b64) {
                            // MIME 자동 감지 (WebP/JPEG/PNG)
                            let mime = 'image/png';
                            if (data.image_b64.startsWith('UklGR')) mime = 'image/webp';
                            else if (data.image_b64.startsWith('/9j/')) mime = 'image/jpeg';
                            imgSrc = `data:${mime};base64,${data.image_b64}`;
                        } else if (data.image_url) {
                            imgSrc = data.image_url;
                        }
                        const imgHtml = `<img src="${imgSrc}" style="width:100%; height:100%; object-fit:contain; border-radius:8px;">`;
                        if (manualResultContainer) manualResultContainer.innerHTML = imgHtml;
                        console.log("Preview generated with prompt:", data.prompt_used);
                    } else {
                        const errHtml = '<div style="color:red; padding:1rem;">에러가 발생했습니다.</div>';
                        showToast('미리보기 생성 실패: ' + (data.error || '알 수 없는 오류'), 'error');
                        if (manualResultContainer) manualResultContainer.innerHTML = errHtml;
                    }
                } else if (res.status === 504) {
                    stopTimer();
                    const err = await res.json().catch(() => ({}));
                    const errMsg = err.detail || '요청 시간이 초과되었습니다. 잠시 후 다시 시도해주세요.';
                    showToast('미리보기 시간 초과: ' + errMsg, 'warning');
                    if (manualResultContainer) manualResultContainer.innerHTML = `<div style="color:var(--warning); padding:1rem; font-size:0.85rem;">${errMsg}</div>`;
                } else {
                    stopTimer();
                    const err = await res.json().catch(() => ({}));
                    const errMsg = (typeof err.detail === 'object' ? JSON.stringify(err.detail) : (err.detail || 'Unknown error'));
                    showToast('미리보기 오류: ' + errMsg, 'error');
                    if (manualResultContainer) manualResultContainer.innerHTML = `<div style="color:red; padding:1rem; font-size:0.8rem;">${errMsg}</div>`;
                }
            } catch (e) {
                stopTimer();
                console.error(e);
                let msg = e.message || String(e);
                const wasManualCancel = (e.name === 'AbortError' || msg.includes('abort'));
                if (wasManualCancel) {
                    // 수동 중단 vs 타임아웃 구분
                    if (seconds < 125) {
                        msg = "미리보기가 사용자에 의해 중단되었습니다.";
                    } else {
                        msg = "요청이 130초 안에 완료되지 않아 자동 중단되었습니다. API가 느리거나 불안정할 수 있습니다.";
                    }
                } else if (msg.includes('Failed to fetch')) {
                    msg = "서버와 연결할 수 없습니다. 서버가 켜져 있는지 확인하거나 잠시 후 다시 시도해주세요.";
                }
                if (!wasManualCancel || seconds >= 125) {
                    showToast('미리보기 실패: ' + msg, 'error');
                }
                if (manualResultContainer) manualResultContainer.innerHTML = `<div style="color:${wasManualCancel && seconds < 125 ? 'var(--text-muted)' : 'red'}; padding:1rem;">${msg}</div>`;
            }
        }

        // ============================================
        // 미리보기 중단용 전역 AbortController
        let previewAbortController = null;

        // [정리됨] 학습 관련 코드 제거 — 3종 레퍼런스 프리셋으로 대체

        const _origGetImageModel = () => 'nano-banana-pro'; // Gemini 3.0 Preview 고정



    // ═══════════════════════════════════════════════
    // 프리셋 관리 시스템 — 갤러리 + 편집 + AI 생성 + 저장
    // ═══════════════════════════════════════════════

    let _presetList = [];
    let _presetPage = 1;
    const _presetsPerPage = 8;
    let _activePreset = null;       // 현재 선택된 프리셋 (스토리 연동용)
    let _editingPresetId = null;    // 편집 중인 프리셋 ID (null이면 신규)
    let _presetSessionId = 'preset_' + Date.now(); // 프리셋 편집용 임시 세션

    // ── 프리셋 갤러리 로드 ──
    async function loadPresetGallery() {
        try {
            const res = await fetch(`/api/reference/presets/list?_t=${Date.now()}`);
            const data = await res.json();
            if (data.success) {
                _presetList = data.presets || [];
                renderPresetGallery();
            }
        } catch (e) {
            console.error('프리셋 목록 로드 실패:', e);
        }
    }

    function renderPresetGallery() {
        const grid = document.getElementById('preset-gallery-grid');
        if (!grid) return;
        grid.innerHTML = '';

        const totalPages = Math.ceil(_presetList.length / _presetsPerPage) || 1;
        if (_presetPage > totalPages) _presetPage = totalPages;

        const start = (_presetPage - 1) * _presetsPerPage;
        const pageItems = _presetList.slice(start, start + _presetsPerPage);

        document.getElementById('preset-page-indicator').innerText = `${_presetPage} / ${totalPages}`;

        if (_presetList.length === 0) {
            grid.innerHTML = '<div style="grid-column:1/-1; text-align:center; padding:2rem; color:var(--text-muted);">저장된 프리셋이 없습니다. "새 프리셋 만들기"를 눌러 첫 프리셋을 만들어보세요.</div>';
            return;
        }

        pageItems.forEach(p => {
            const isActive = _activePreset && _activePreset.id === p.id;
            const card = document.createElement('div');
            card.style.cssText = `background:var(--bg-card); border:2px solid ${isActive ? 'var(--primary)' : 'var(--border)'}; border-radius:10px; padding:10px; cursor:pointer; transition:all 0.2s; position:relative;${isActive ? ' box-shadow:0 0 0 2px var(--primary);' : ''}`;
            card.onmouseenter = () => { if (!isActive) card.style.borderColor = 'var(--primary)'; card.style.transform = 'translateY(-2px)'; };
            card.onmouseleave = () => { if (!isActive) card.style.borderColor = 'var(--border)'; card.style.transform = 'none'; };

            // 3분할 썸네일
            const thumbs = ['character', 'method', 'style'].map(t => {
                const has = p[`has_${t}`];
                return `<div style="flex:1; aspect-ratio:1; background:var(--bg-input); border-radius:4px; overflow:hidden; display:flex; align-items:center; justify-content:center;">
                    ${has ? `<img src="/api/reference/presets/${p.id}/thumbnail/${t}?t=${Date.now()}" style="width:100%; height:100%; object-fit:cover;" onerror="this.style.display='none'">` : `<span style="font-size:0.6rem; color:var(--text-muted);">${t[0].toUpperCase()}</span>`}
                </div>`;
            }).join('');

            // 뱃지
            const badge = p.source === 'builtin'
                ? '<span style="font-size:0.65rem; padding:1px 6px; border-radius:3px; background:rgba(99,102,241,0.2); color:var(--primary);">내장</span>'
                : '<span style="font-size:0.65rem; padding:1px 6px; border-radius:3px; background:rgba(16,185,129,0.2); color:#10b981;">커스텀</span>';

            // 캐릭터 이름 태그
            const charNames = (p.character_names || []).join(', ') || '';

            card.innerHTML = `
                <div style="display:flex; gap:4px; margin-bottom:8px;">${thumbs}</div>
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <span style="font-size:0.85rem; font-weight:700; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; flex:1;">${p.name || p.id}</span>
                    ${badge}
                </div>
                ${charNames ? `<div style="font-size:0.7rem; color:var(--text-muted); margin-top:4px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${charNames}</div>` : ''}
                ${p.source !== 'builtin' ? `<button onclick="event.stopPropagation(); deletePreset('${p.id}', '${(p.name||'').replace(/'/g,"\\'")}')" style="position:absolute; top:6px; right:6px; background:rgba(239,68,68,0.8); color:#fff; border:none; border-radius:50%; width:20px; height:20px; font-size:0.7rem; cursor:pointer; display:flex; align-items:center; justify-content:center;">×</button>` : ''}
            `;
            card.onclick = () => selectPresetForEdit(p);
            grid.appendChild(card);
        });
    }

    function prevPresetPage() { if (_presetPage > 1) { _presetPage--; renderPresetGallery(); } }
    function nextPresetPage() {
        const totalPages = Math.ceil(_presetList.length / _presetsPerPage) || 1;
        if (_presetPage < totalPages) { _presetPage++; renderPresetGallery(); }
    }

    // ── 프리셋 선택 (편집 영역에 로드) ──
    async function selectPresetForEdit(preset) {
        _editingPresetId = preset.id;
        document.getElementById('preset-editor').style.display = 'block';
        document.getElementById('preset-editor-title').innerText = `프리셋 편집: ${preset.name || preset.id}`;
        document.getElementById('preset-name-input').value = preset.name || '';
        document.getElementById('preset-char-names-input').value = (preset.character_names || []).join(', ');

        // 프리셋 적용 (임시 세션에 복사)
        try {
            await fetch(`/api/reference/presets/${preset.id}/apply`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ session_id: _presetSessionId })
            });
        } catch (e) { console.warn('프리셋 적용 실패:', e); }

        // 3장 미리보기 로드
        ['character', 'method', 'style'].forEach(t => {
            const preview = document.getElementById(`ref-preview-${t}`);
            const status = document.getElementById(`ref-status-${t}`);
            if (preset[`has_${t}`]) {
                preview.innerHTML = `<img src="/api/reference/presets/${preset.id}/thumbnail/${t}?t=${Date.now()}" style="width:100%; height:100%; object-fit:cover;">`;
                status.innerText = '설정됨';
                status.style.background = 'rgba(16,185,129,0.2)';
                status.style.color = '#10b981';
            } else {
                preview.innerHTML = '<span style="color:var(--text-muted); font-size:0.8rem; text-align:center; padding:1rem;">프리뷰 영역<br><span style="font-size:0.7rem;">AI 생성 또는 파일 버튼으로 설정</span></span>';
                status.innerText = '미설정';
                status.style.background = 'var(--bg-input)';
                status.style.color = 'var(--text-muted)';
            }
        });

        renderPresetGallery(); // 하이라이트 갱신
    }

    // ── 새 프리셋 만들기 ──
    function startNewPreset() {
        _editingPresetId = null;
        _presetSessionId = 'preset_' + Date.now();
        document.getElementById('preset-editor').style.display = 'block';
        document.getElementById('preset-editor-title').innerText = '새 프리셋 만들기';
        document.getElementById('preset-name-input').value = '';
        document.getElementById('preset-char-names-input').value = '';

        ['character', 'method', 'style'].forEach(t => {
            const preview = document.getElementById(`ref-preview-${t}`);
            const status = document.getElementById(`ref-status-${t}`);
            preview.innerHTML = '<span style="color:var(--text-muted); font-size:0.8rem; text-align:center; padding:1rem;">프리뷰 영역<br><span style="font-size:0.7rem;">AI 생성 또는 파일 버튼으로 설정</span></span>';
            status.innerText = '미설정';
            status.style.background = 'var(--bg-input)';
            status.style.color = 'var(--text-muted)';
            document.getElementById(`ref-prompt-${t}`).value = '';
        });
    }

    // ── 레퍼런스 파일 업로드 ──
    async function handleRefUpload(refType, inputEl) {
        const file = inputEl.files[0];
        if (!file) return;

        const formData = new FormData();
        formData.append('file', file);
        formData.append('session_id', _presetSessionId);

        // 캐릭터 이미지 업로드 시 이름 오버레이 적용
        if (refType === 'character') {
            const charNamesInput = document.getElementById('preset-char-names-input');
            if (charNamesInput) {
                const names = charNamesInput.value.split(',').map(n => n.trim()).filter(n => n);
                if (names.length > 0) {
                    formData.append('character_name', names[0]);
                    formData.append('character_role', '주인공');
                }
            }
        }

        try {
            const res = await fetch(`/api/reference/upload/${refType}`, { method: 'POST', body: formData });
            const data = await res.json();
            if (data.success) {
                const preview = document.getElementById(`ref-preview-${refType}`);
                const reader = new FileReader();
                reader.onload = (e) => { preview.innerHTML = `<img src="${e.target.result}" style="width:100%; height:100%; object-fit:cover;">`; };
                reader.readAsDataURL(file);

                const status = document.getElementById(`ref-status-${refType}`);
                status.innerText = '설정됨';
                status.style.background = 'rgba(16,185,129,0.2)';
                status.style.color = '#10b981';

                showToast(`${refType} 레퍼런스 업로드 완료`, 'success');
            }
        } catch (e) {
            showToast('업로드 실패: ' + e.message, 'error');
        }
        inputEl.value = '';
    }

    // ── 예시 프롬프트 채우기 ──
    function fillExamplePrompt(refType) {
        const examples = {
            character: '녹색 배경, 한국 웹툰 스타일의 젊은 남성 캐릭터. 단정한 짧은 머리, 깨끗한 정장. 정면을 바라보는 전신 포즈. 깔끔한 선화, 밝은 색감.',
            method: 'Character.jpg의 캐릭터 화풍을 유지한 채 웹툰 연출 장면을 그려줘. 4~6컷으로 나뉜 만화 레이아웃, 다양한 카메라 앵글(전신, 클로즈업, 뒷모습).',
            style: 'Character.jpg의 캐릭터를 참고해서 스타일을 강조하는 이미지를 만들어줘. 배경 디테일이 풍부한 완성된 일러스트레이션. 색감과 분위기가 잘 드러나는 구도.'
        };
        const textarea = document.getElementById(`ref-prompt-${refType}`);
        if (textarea && examples[refType]) {
            textarea.value = examples[refType];
            showToast('예시 프롬프트가 채워졌습니다', 'success');
        }
    }

    // ── AI 레퍼런스 생성 ──
    async function generateRef(refType) {
        const prompt = document.getElementById(`ref-prompt-${refType}`).value.trim();
        if (!prompt) { showToast('프롬프트를 입력해주세요', 'error'); return; }

        const typeLabels = { character: '캐릭터', method: '연출', style: '스타일' };
        const label = typeLabels[refType] || refType;

        // 해당 카드의 프리뷰 영역에 로딩 표시
        const preview = document.getElementById(`ref-preview-${refType}`);
        const statusEl = document.getElementById(`ref-status-${refType}`);
        const card = document.getElementById(`ref-card-${refType}`);

        // 버튼 비활성화 (중복 클릭 방지)
        const genBtn = card?.querySelector('button[onclick*="generateRef"]');
        if (genBtn) { genBtn.disabled = true; genBtn.style.opacity = '0.5'; }

        // 프리뷰 영역에 로딩 애니메이션 + 경과 시간 표시
        const startTime = Date.now();
        preview.innerHTML = `
            <div style="display:flex; flex-direction:column; align-items:center; justify-content:center; height:100%; gap:0.75rem;">
                <div style="width:36px; height:36px; border:3px solid var(--border); border-top-color:var(--primary); border-radius:50%; animation:spin 1s linear infinite;"></div>
                <span style="color:var(--primary); font-size:0.85rem; font-weight:600;">${label} 생성 중...</span>
                <span id="ref-timer-${refType}" style="color:var(--text-muted); font-size:0.7rem;">경과: 0초</span>
            </div>`;

        // 상태 배지 업데이트
        if (statusEl) {
            statusEl.innerText = '생성 중...';
            statusEl.style.background = 'rgba(99,102,241,0.2)';
            statusEl.style.color = '#818cf8';
        }

        // 경과 시간 타이머
        const timerInterval = setInterval(() => {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const timerEl = document.getElementById(`ref-timer-${refType}`);
            if (timerEl) timerEl.innerText = `경과: ${elapsed}초`;
        }, 1000);

        // 하단 로딩바도 표시
        const loadingEl = document.getElementById('ref-gen-loading');
        const loadingText = document.getElementById('ref-gen-loading-text');
        loadingEl.style.display = 'block';
        loadingText.innerText = `${label} 레퍼런스를 AI가 생성하고 있습니다...`;

        try {
            const bodyData = { prompt, session_id: _presetSessionId, model_name: 'nano-banana-pro' };

            // 캐릭터 생성 시 이름 텍스트 오버레이 + 스타일 참조
            if (refType === 'character') {
                // 프리셋 캐릭터 이름 목록에서 첫 번째 이름을 이미지에 합성
                const charNamesInput = document.getElementById('preset-char-names-input');
                if (charNamesInput) {
                    const names = charNamesInput.value.split(',').map(n => n.trim()).filter(n => n);
                    if (names.length > 0) {
                        bodyData.character_name = names[0];
                        bodyData.character_role = '주인공';
                    }
                }
                const stylePreview = document.getElementById('ref-preview-style');
                const styleImg = stylePreview?.querySelector('img');
                if (styleImg && styleImg.src) {
                    try {
                        const resp = await fetch(styleImg.src);
                        const blob = await resp.blob();
                        const reader = new FileReader();
                        const base64 = await new Promise(resolve => {
                            reader.onload = () => resolve(reader.result);
                            reader.readAsDataURL(blob);
                        });
                        bodyData.style_image_base64 = base64;
                    } catch (e) { /* 스타일 참조 실패는 무시 */ }
                }
            }

            const res = await fetch(`/api/reference/generate-${refType}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(bodyData)
            });
            const data = await res.json();

            if (!res.ok) {
                preview.innerHTML = `
                    <div style="display:flex; flex-direction:column; align-items:center; justify-content:center; height:100%; gap:0.5rem;">
                        <span style="font-size:1.5rem;">❌</span>
                        <span style="color:#ef4444; font-size:0.8rem; text-align:center; padding:0 1rem;">${data.detail || 'AI 생성 실패'}</span>
                    </div>`;
                if (statusEl) { statusEl.innerText = '생성 실패'; statusEl.style.background = 'rgba(239,68,68,0.2)'; statusEl.style.color = '#ef4444'; }
                showToast(data.detail || data.error || 'AI 생성 실패', 'error');
                return;
            }

            const b64 = data.image_base64;
            if (data.success && b64 && typeof b64 === 'string' && b64.length > 50) {
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                const img = document.createElement('img');
                img.src = b64;
                img.style.cssText = 'width:100%; height:100%; object-fit:cover;';
                img.onerror = function() {
                    preview.innerHTML = `
                        <div style="display:flex; flex-direction:column; align-items:center; justify-content:center; height:100%; gap:0.5rem;">
                            <span style="font-size:1.5rem;">⚠️</span>
                            <span style="color:#ef4444; font-size:0.8rem;">이미지 로드 실패</span>
                        </div>`;
                    if (statusEl) { statusEl.innerText = '로드 실패'; statusEl.style.background = 'rgba(239,68,68,0.2)'; statusEl.style.color = '#ef4444'; }
                    showToast('생성된 이미지 표시에 실패했습니다', 'error');
                };
                preview.innerHTML = '';
                preview.appendChild(img);
                if (statusEl) {
                    statusEl.innerText = `AI 생성됨 (${elapsed}초)`;
                    statusEl.style.background = 'rgba(16,185,129,0.2)';
                    statusEl.style.color = '#10b981';
                }
                showToast(`${label} 레퍼런스 AI 생성 완료! (${elapsed}초)`, 'success');
            } else {
                preview.innerHTML = `
                    <div style="display:flex; flex-direction:column; align-items:center; justify-content:center; height:100%; gap:0.5rem;">
                        <span style="font-size:1.5rem;">❌</span>
                        <span style="color:#ef4444; font-size:0.8rem;">응답 형식 오류</span>
                    </div>`;
                if (statusEl) { statusEl.innerText = '생성 실패'; statusEl.style.background = 'rgba(239,68,68,0.2)'; statusEl.style.color = '#ef4444'; }
                showToast(data.detail || data.error || 'AI 생성 실패 (응답 형식 오류)', 'error');
            }
        } catch (e) {
            preview.innerHTML = `
                <div style="display:flex; flex-direction:column; align-items:center; justify-content:center; height:100%; gap:0.5rem;">
                    <span style="font-size:1.5rem;">❌</span>
                    <span style="color:#ef4444; font-size:0.8rem; text-align:center; padding:0 1rem;">${e.message}</span>
                </div>`;
            if (statusEl) { statusEl.innerText = '오류'; statusEl.style.background = 'rgba(239,68,68,0.2)'; statusEl.style.color = '#ef4444'; }
            showToast('AI 생성 오류: ' + e.message, 'error');
        } finally {
            clearInterval(timerInterval);
            loadingEl.style.display = 'none';
            // 버튼 복원
            if (genBtn) { genBtn.disabled = false; genBtn.style.opacity = '1'; }
        }
    }

    // ── 프리셋 저장 ──
    async function saveCurrentPreset() {
        const name = document.getElementById('preset-name-input').value.trim();
        if (!name) { showToast('프리셋 이름을 입력해주세요', 'error'); return; }

        const charNamesRaw = document.getElementById('preset-char-names-input').value;
        const charNames = charNamesRaw.split(',').map(n => n.trim()).filter(n => n);

        try {
            const res = await fetch('/api/reference/presets/save', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    name,
                    description: '',
                    character_names: charNames,
                    session_id: _presetSessionId
                })
            });
            const data = await res.json();
            if (data.success) {
                showToast(`프리셋 "${name}" 저장 완료!`, 'success');
                // 갤러리 새로고침
                await loadPresetGallery();
                // 방금 저장한 프리셋을 활성으로 설정
                const saved = _presetList.find(p => p.id === data.preset_id);
                if (saved) _activePreset = saved;
                // 저장한 프리셋이 있는 페이지로 이동
                if (saved) {
                    const idx = _presetList.indexOf(saved);
                    _presetPage = Math.floor(idx / _presetsPerPage) + 1;
                    renderPresetGallery();
                }
                // 갤러리 영역이 보이도록 스크롤
                const galleryEl = document.getElementById('preset-gallery-grid');
                if (galleryEl) galleryEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                // 스토리 탭 프리셋 목록도 갱신
                if (typeof refreshStoryPresetSelector === 'function') refreshStoryPresetSelector();
            } else {
                showToast(data.error || '저장 실패', 'error');
            }
        } catch (e) {
            showToast('저장 오류: ' + e.message, 'error');
        }
    }

    // ── 프리셋 삭제 ──
    async function deletePreset(presetId, presetName) {
        if (!confirm(`프리셋 "${presetName}"을 삭제하시겠습니까?`)) return;
        try {
            const res = await fetch(`/api/reference/presets/${presetId}`, { method: 'DELETE' });
            const data = await res.json();
            if (data.success) {
                showToast(`프리셋 "${presetName}" 삭제 완료`, 'success');
                if (_activePreset && _activePreset.id === presetId) _activePreset = null;
                if (_editingPresetId === presetId) {
                    _editingPresetId = null;
                    document.getElementById('preset-editor').style.display = 'none';
                }
                await loadPresetGallery();
                // 스토리 탭 프리셋 목록도 갱신
                if (typeof refreshStoryPresetSelector === 'function') refreshStoryPresetSelector();
            } else {
                showToast(data.error || '삭제 실패', 'error');
            }
        } catch (e) {
            showToast('삭제 오류: ' + e.message, 'error');
        }
    }

    // ── 테스트 생성 ──
    async function testPresetGeneration() {
        const loadingEl = document.getElementById('ref-gen-loading');
        const loadingText = document.getElementById('ref-gen-loading-text');
        loadingEl.style.display = 'block';
        loadingText.innerText = '테스트 이미지를 생성하고 있습니다... (레퍼런스 3장 적용)';

        try {
            const res = await fetch('/api/reference/test-preview', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    model_name: 'nano-banana-pro',
                    prompt: '두 캐릭터가 카페에서 대화하는 따뜻한 장면',
                    session_id: _presetSessionId
                })
            });
            const data = await res.json();
            if (data.success && data.image_base64) {
                const resultArea = document.getElementById('preset-test-result');
                const resultImg = document.getElementById('preset-test-image');
                resultArea.style.display = 'block';
                resultImg.innerHTML = `<img src="${data.image_base64}" style="width:100%; border-radius:8px; box-shadow:0 4px 16px rgba(0,0,0,0.12);">`;
                showToast('테스트 이미지 생성 완료!', 'success');
            } else {
                showToast(data.error || '테스트 생성 실패', 'error');
            }
        } catch (e) {
            showToast('테스트 생성 오류: ' + e.message, 'error');
        } finally {
            loadingEl.style.display = 'none';
        }
    }

    // ═══════════════════════════════════════════════
    // Phase 4: 스토리 탭 프리셋 선택 (컴팩트 갤러리)
    // ═══════════════════════════════════════════════

    let _storyPresetPage = 1;
    const _storyPresetsPerPage = 4;

    async function refreshStoryPresetSelector() {
        try {
            const res = await fetch('/api/reference/presets/list');
            const data = await res.json();
            if (data.success) _presetList = data.presets || [];
        } catch (e) { /* 무시 */ }
        renderStoryPresetGallery();
    }

    function renderStoryPresetGallery() {
        const container = document.getElementById('story-preset-gallery');
        if (!container) return;
        container.innerHTML = '';

        if (_presetList.length === 0) {
            container.innerHTML = '<div style="text-align:center; padding:1rem; color:var(--text-muted); font-size:0.85rem;">프리셋이 없습니다. <a href="#" onclick="navigateToStep(\'preset\'); return false;" style="color:var(--primary);">프리셋 관리</a>에서 먼저 만들어주세요.</div>';
            return;
        }

        const totalPages = Math.ceil(_presetList.length / _storyPresetsPerPage) || 1;
        if (_storyPresetPage > totalPages) _storyPresetPage = totalPages;

        const start = (_storyPresetPage - 1) * _storyPresetsPerPage;
        const pageItems = _presetList.slice(start, start + _storyPresetsPerPage);

        const grid = document.createElement('div');
        grid.style.cssText = 'display:grid; grid-template-columns:repeat(4, 1fr); gap:8px; margin-bottom:8px;';

        pageItems.forEach(p => {
            const isActive = _activePreset && _activePreset.id === p.id;
            const card = document.createElement('div');
            card.style.cssText = `background:var(--bg-card); border:2px solid ${isActive ? 'var(--primary)' : 'var(--border)'}; border-radius:8px; padding:8px; cursor:pointer; transition:all 0.2s;${isActive ? ' box-shadow:0 0 0 2px var(--primary);' : ''}`;
            card.onmouseenter = () => { if (!isActive) card.style.borderColor = 'var(--primary)'; };
            card.onmouseleave = () => { if (!isActive) card.style.borderColor = 'var(--border)'; };

            const thumbs = ['character', 'method', 'style'].map(t => {
                const has = p[`has_${t}`];
                return `<div style="flex:1; aspect-ratio:1; background:var(--bg-input); border-radius:3px; overflow:hidden;">
                    ${has ? `<img src="/api/reference/presets/${p.id}/thumbnail/${t}?t=${Date.now()}" style="width:100%; height:100%; object-fit:cover;" onerror="this.style.display='none'">` : ''}
                </div>`;
            }).join('');

            card.innerHTML = `
                <div style="display:flex; gap:3px; margin-bottom:6px;">${thumbs}</div>
                <div style="font-size:0.75rem; font-weight:700; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${p.name || p.id}</div>
            `;
            card.onclick = () => selectPresetForStory(p);
            grid.appendChild(card);
        });

        container.appendChild(grid);

        // 페이지네이션
        if (totalPages > 1) {
            const pag = document.createElement('div');
            pag.style.cssText = 'display:flex; justify-content:center; gap:0.5rem; align-items:center;';
            pag.innerHTML = `
                <button class="btn btn-sm btn-outline" onclick="storyPresetPrev()" style="font-size:0.7rem; padding:2px 8px;">←</button>
                <span style="font-size:0.75rem; color:var(--text-muted);">${_storyPresetPage}/${totalPages}</span>
                <button class="btn btn-sm btn-outline" onclick="storyPresetNext()" style="font-size:0.7rem; padding:2px 8px;">→</button>
            `;
            container.appendChild(pag);
        }

        // 선택 상태 라벨
        const label = document.getElementById('story-preset-label');
        if (label) {
            label.innerText = _activePreset ? `선택됨: ${_activePreset.name}` : '프리셋을 선택해주세요';
            label.style.color = _activePreset ? 'var(--primary)' : 'var(--text-muted)';
        }
    }

    function storyPresetPrev() { if (_storyPresetPage > 1) { _storyPresetPage--; renderStoryPresetGallery(); } }
    function storyPresetNext() {
        const tp = Math.ceil(_presetList.length / _storyPresetsPerPage) || 1;
        if (_storyPresetPage < tp) { _storyPresetPage++; renderStoryPresetGallery(); }
    }

    // ── 이미지 생성 시 프리셋 레퍼런스를 세션에 자동 적용 ──
    async function applyPresetReferencesToSession() {
        if (!_activePreset) {
            console.log('선택된 프리셋 없음 — 기존 레퍼런스 유지');
            return;
        }
        try {
            const res = await fetch(`/api/reference/presets/${_activePreset.id}/apply`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ session_id: sessionId })
            });
            const data = await res.json();
            if (data.success) {
                console.log(`프리셋 "${_activePreset.name}" 레퍼런스가 세션에 적용됨`);
            }
        } catch (e) {
            console.warn('프리셋 레퍼런스 적용 실패:', e);
        }
    }

    function selectPresetForStory(preset) {
        _activePreset = preset;

        // 캐릭터 이름 자동 반영
        if (preset.character_names && preset.character_names.length > 0) {
            const nameInput = document.getElementById('character-names-input');
            if (nameInput) nameInput.value = preset.character_names.join(', ');
        }

        renderStoryPresetGallery();
        renderPresetGallery(); // 프리셋관리 탭도 동기화
        showToast(`프리셋 "${preset.name}" 선택됨 — 캐릭터 이름 반영 완료`, 'success');
    }

    // ============================================
    // 프로젝트 저장/불러오기
    // ============================================
    async function toggleProjectPanel() {
        const panel = document.getElementById('project-list-panel');
        if (panel.style.display === 'block') {
            panel.style.display = 'none';
            return;
        }
        panel.style.display = 'block';
        // 저장 힌트 업데이트
        const hint = document.getElementById('project-save-hint');
        if (hint) hint.style.display = sessionId ? 'none' : 'inline';
        await refreshProjectList();
    }

    async function refreshProjectList() {
        const content = document.getElementById('project-list-content');
        content.innerHTML = '로딩 중...';
        try {
            const res = await fetch('/api/workflow/project/list');
            const data = await res.json();
            if (!data.projects || data.projects.length === 0) {
                content.innerHTML = '<div style="color:var(--text-muted); font-size:0.85rem; padding:1rem; text-align:center;">저장된 프로젝트가 없습니다.</div>';
                return;
            }
            content.innerHTML = data.projects.map(p => {
                const date = p.saved_at ? new Date(p.saved_at).toLocaleString('ko-KR') : '';
                return '<div style="display:flex; justify-content:space-between; align-items:center; padding:0.6rem 0.75rem; border-bottom:1px solid var(--border);">'
                    + '<div>'
                    + '<div style="font-weight:600; font-size:0.88rem;">' + (p.project_name || p.dirname) + '</div>'
                    + '<div style="font-size:0.72rem; color:var(--text-muted);">' + date + ' · 씬 ' + p.scene_count + '장 · 시리즈 ' + p.series_count + '편 · 이미지 ' + p.image_count + '개</div>'
                    + '</div>'
                    + '<div style="display:flex; gap:0.4rem;">'
                    + '<button class="btn btn-primary" style="font-size:0.72rem; padding:4px 10px;" onclick="loadProject(\'' + p.dirname + '\')">불러오기</button>'
                    + '<button style="background:none; border:none; cursor:pointer; color:var(--danger); font-size:1rem;" onclick="deleteProject(\'' + p.dirname + '\')" title="삭제">×</button>'
                    + '</div></div>';
            }).join('');
        } catch(e) {
            content.innerHTML = '<div style="color:var(--danger);">목록 로드 실패: ' + e.message + '</div>';
        }
    }

    async function loadProject(dirname) {
        try {
            const res = await fetch('/api/workflow/project/load', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ dirname: dirname })
            });
            const data = await res.json();
            if (!data.success) { showToast('불러오기 실패: ' + (data.detail || ''), 'error'); return; }

            sessionId = data.session_id;
            if (data.story) {
                storyData = data.story;
                characters = data.story.characters || [];
            }
            if (data.series_config) {
                seriesConfig = {
                    total: data.series_config.total || 1,
                    scenesPerSeries: data.story ? (data.story.scenes_per_series || []) : []
                };
            }

            document.getElementById('project-list-panel').style.display = 'none';

            // 스토리가 있으면 Tab 3으로 이동
            if (storyData && storyData.scenes && storyData.scenes.length > 0) {
                goToStep(3);
                renderCharacters();
                renderScenes(storyData.scenes);
                showSeriesPanel();
                document.getElementById('story-review-area').style.display = 'block';
            }
            showToast('프로젝트 "' + data.project_name + '" 불러오기 완료', 'success');
        } catch(e) {
            showToast('불러오기 오류: ' + e.message, 'error');
        }
    }

    async function saveCurrentProject() {
        if (!sessionId) { showToast('저장할 세션이 없습니다.', 'warning'); return; }
        const name = prompt('프로젝트 이름을 입력하세요:', storyData ? (storyData.title || '') : '');
        if (!name) return;
        try {
            const res = await fetch('/api/workflow/project/save', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ session_id: sessionId, project_name: name })
            });
            const data = await res.json();
            if (data.success) {
                showToast('프로젝트 저장 완료 (이미지 ' + data.image_count + '개)', 'success');
            } else {
                showToast('저장 실패: ' + (data.detail || ''), 'error');
            }
        } catch(e) { showToast('저장 오류: ' + e.message, 'error'); }
    }

    async function deleteProject(dirname) {
        if (!confirm('이 프로젝트를 삭제하시겠습니까?')) return;
        try {
            await fetch('/api/workflow/project/delete/' + dirname, { method: 'DELETE' });
            showToast('프로젝트 삭제됨', 'info');
            refreshProjectList();
        } catch(e) { showToast('삭제 오류: ' + e.message, 'error'); }
    }

    </script>
</body>

</html>