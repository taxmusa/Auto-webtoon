# 전체 검증 및 심도 분석 보고

작성 목적: 서버 재시작/리로드 후 접속 불안정, 리프레시 느림, 탭3 이미지 생성 지연·오류 감각에 대한 원인 분석 및 개선 방향 정리.

---

## 1. 서버 재시작·리로드 후 접속이 잘 안 되고 느린 현상

### 1.1 원인 요약

| 요인 | 설명 |
|------|------|
| **reload=True** | `run.py`에서 `uvicorn.run(..., reload=True)` 사용 시 WatchFiles가 **전체 프로젝트 디렉터리**를 감시. 파일 변경 시 부모 프로세스가 자식 재시작 → 재시작 구간에 새 요청이 들어오면 연결 실패·지연 발생. |
| **앱 로드 비용** | `main.py`에서 **라우터 8개**를 한꺼번에 import. `workflow_router`만 해도 `workflow.py`(약 3,000줄)와 그 안의 다수 서비스 import. 재시작할 때마다 이 전체가 다시 로드됨. |
| **루트(/) 응답 비용** | `GET /` 요청 시 **Jinja2로 index.html 한 번에 렌더링**. 템플릿이 **약 442KB, 7,940줄**이라 파싱·렌더링에 수백 ms 단위 시간 소요 가능. |

### 1.2 정리

- **리로드 시**: WatchFiles가 변경 감지 → 프로세스 재시작 → 그동안 들어온 요청은 끊기거나 지연 → “접속이 안 된다”로 체감.
- **리프레시 시**: 매번 442KB HTML을 받고, 브라우저가 7,940줄+ 인라인 스크립트 파싱·실행 → **첫 로드·리로드가 체감상 느려짐**.

---

## 2. 탭3 이미지 생성이 “너무 느리다 / 오류 수준 같다”

### 2.1 현재 동작 방식

- **클라이언트**: `POST /api/workflow/generate-images` 호출 후 **응답이 올 때까지 대기** (별도 fetch 타임아웃·AbortController 없음).
- **서버**: 요청을 받은 뒤 **모든 씬을 순차 생성한 뒤** 한 번에 200 응답.
- **흐름**: 씬 1 생성(약 15~90초) → 1초 대기 → 씬 2 생성 → … → 씬 N 완료 후 응답.  
  → **10개 씬 기준 대략 3~6분** 걸리는 구조.

### 2.2 “느린 게 아니라 오류 수준”으로 느껴질 수 있는 지점

1. **HTTP 연결 유지 시간**
   - 한 요청이 3~6분 동안 열려 있음.
   - 중간 프록시·방화벽·Wi‑Fi 등에서 **2분 전후로 keep-alive/요청 타임아웃**으로 끊는 경우, 브라우저에서는 “요청 실패”로 보이지만 서버는 계속 생성 중일 수 있음.
   - 그러면 “이미지가 하나씩는 올라오는데, 어느 순간 에러가 난다” 같은 모순된 체감이 생길 수 있음.

2. **진행 피드백**
   - 진행 상황은 **폴링**(`GET /api/workflow/session/{id}`)으로만 갱신.
   - POST는 끝날 때까지 응답이 없으므로, **“요청이 멈춘 것처럼”** 보일 수 있고, 실제로 중간에 연결이 끊기면 에러만 보이므로 “오류 수준”으로 느껴질 수 있음.

3. **재시도·타임아웃**
   - `image_generator.py`: 씬당 **90초 타임아웃**, 429/504/타임아웃 시 재시도(대기 5~30초 등).
   - 한 씬이 여러 번 재시도되면 그 씬만 2~3분 걸릴 수 있어, **전체 체감 시간이 크게 늘어남**.

### 2.3 코드 관점 정리

- **이벤트 루프 블로킹**: Gemini 호출은 `asyncio.to_thread(_sync_generate)`로 스레드에서 실행되어, 다른 요청을 막지는 않음.
- **파일 I/O**: 이미지 저장은 `asyncio.to_thread`로 처리되어 있음.
- **구조적 문제**: “한 번에 N개 씬 다 만들고 응답”이라는 설계 자체가 **긴 연결 시간**과 **중간 끊김 시 오류 체감**을 만드는 핵심.

---

## 3. index.html 단일 대형 템플릿

- **크기**: 약 **442KB**, **7,940줄**.
- **영향**:
  - 매 `GET /` 요청 시 Jinja2가 이 템플릿 전체 파싱·렌더링.
  - 브라우저는 442KB HTML + 수천 줄 인라인 스크립트를 받아 파싱·실행.
- **결과**: 첫 로드·리프레시가 무거워지고, “리로드가 너무 느리다”에 기여.

---

## 4. 종합 원인 정리

| 현상 | 주요 원인 |
|------|------------|
| 서버 재시작 후 접속 불안정 | reload=True로 인한 재시작 구간 + 재시작 시 전체 앱 재로드 |
| 리프레시 후 느림 | 442KB·7,940줄 단일 HTML 템플릿 + 인라인 스크립트 과다 |
| 탭3 이미지 생성 “너무 느림/오류 같음” | ① 3~6분 단일 HTTP 요청 ② 중간 프록시/네트워크 타임아웃(예: 2분) 가능성 ③ 진행은 폴링뿐이라 “멈춘 것처럼” 보임 |

---

## 5. 개선 제안 (우선순위)

### 5.1 단기 (구조 유지한 채 완화)

1. **이미지 생성 API**
   - **옵션 A**: `POST /generate-images`를 **202 Accepted**로 즉시 반환하고, 실제 생성은 백그라운드 태스크로 수행. 클라이언트는 기존처럼 세션 폴링만 사용.  
     → HTTP 연결이 길게 유지되지 않아, 2분 타임아웃 등으로 끊길 가능성 감소.
   - **옵션 B**: 변경 최소화라면, 최소한 **클라이언트 fetch에 명시적 긴 타임아웃**(예: 600초) 또는 “이미지 생성은 수 분 걸릴 수 있음” 안내만 추가해, 끊김 시 원인 파악이 쉽게.

2. **리로드 시 접속**
   - 개발 시에만 `reload=True` 사용하고, 실제 사용(데모/테스트) 시에는 `reload=False`로 실행해 재시작 빈도를 줄이기.
   - 또는 `run.py`에서 **reload 시 감시 디렉터리 제한**(예: `app/`만 감시)으로 재시작 범위 축소 검토.

3. **루트(/) 응답**
   - index.html을 **정적 HTML로 빌드**해 두고, `/`에서는 그 파일만 서빙하거나,  
   - Jinja2 사용을 유지하더라도 **공통 레이아웃 + 작은 조각**으로 나누어 렌더 부담을 줄이는 방향 검토.

### 5.2 중기 (구조 개선)

4. **탭3 이미지 생성 흐름**
   - “요청 수락 → 백그라운드 작업 → 폴링/SSE로 진행률만 전달” 구조로 전환하면,  
     긴 단일 요청·타임아웃·“멈춘 것 같다”는 느낌을 동시에 완화할 수 있음.

5. **프론트엔드**
   - 단일 7,940줄 페이지를 **탭/기능별 스크립트 분리** 또는 **lazy 로딩**으로 나누면, 리프레시·첫 로드 체감이 개선될 여지가 있음.

### 5.3 검증 체크리스트 (추가 점검 시)

- [ ] 방화벽/프록시에서 HTTP 요청 타임아웃 값 확인 (예: 60초, 120초).
- [ ] 브라우저 개발자 도구 Network에서 `generate-images` 요청이 **Pending 후 Failed**로 바뀌는지, 그 시점(몇 분 후인지) 확인.
- [ ] 서버 로그에서 `generate-images` 요청 직후 씬별 로그가 계속 찍히는지(실제로는 정상 생성 중인지) 확인.
- [ ] `reload=False`로 서버 실행 시, 리프레시 후 접속·체감 속도가 나아지는지 비교.

---

## 6. 요약

- **접속 불안정·리로드 느림**: `reload=True` + 대형 단일 템플릿(442KB) + 무거운 앱 로드가 겹친 결과로 보는 것이 타당함.
- **탭3 이미지 생성 “너무 느림/오류 같음”**:  
  “한 요청이 3~6분 동안 유지되는 구조”와 “중간 네트워크 타임아웃 가능성”, “진행 피드백이 폴링뿐”인 점이 합쳐져, 느리면서도 오류처럼 느껴질 수 있음.
- **즉시 적용 가능한 완화**:  
  이미지 생성은 202+백그라운드 처리 검토, 개발 시 reload 최소화 또는 감시 범위 축소, 루트 응답 경량화(또는 정적화)를 우선 검토하는 것을 권장함.
